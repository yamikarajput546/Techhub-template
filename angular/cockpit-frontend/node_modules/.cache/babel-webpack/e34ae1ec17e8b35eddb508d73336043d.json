{"ast":null,"code":"import _toConsumableArray from \"/home/knoldus/Projects/cockpit-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createClass from \"/home/knoldus/Projects/cockpit-frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/home/knoldus/Projects/cockpit-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Injectable, ɵɵdefineInjectable, EventEmitter, Component, NgZone, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3 } from 'ngx-bootstrap/utils';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction CarouselComponent_ol_1_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_ol_1_li_1_Template_li_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      var i_r5 = ctx.index;\n      var ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r6.selectSlide(i_r5);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var slide_r4 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", slide_r4.active === true);\n  }\n}\n\nfunction CarouselComponent_ol_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"ol\", 5);\n    ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_li_1_Template, 1, 2, \"li\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\n\nfunction CarouselComponent_a_4_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 11);\n    ɵngcc0.ɵɵtext(1, \"Previous\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction CarouselComponent_a_4_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"a\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_4_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      var ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.previousSlide();\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 9);\n    ɵngcc0.ɵɵtemplate(2, CarouselComponent_a_4_span_2_Template, 2, 0, \"span\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r1.activeSlide === 0 && ctx_r1.noWrap);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.isBs4);\n  }\n}\n\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r12 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"a\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      var ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11.nextSlide();\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 13);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 11);\n    ɵngcc0.ɵɵtext(3, \"Next\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"disabled\", ctx_r2.isLast(ctx_r2.activeSlide) && ctx_r2.noWrap);\n  }\n}\n\nvar _c0 = function _c0(a0) {\n  return {\n    \"display\": a0\n  };\n};\n\nvar _c1 = [\"*\"];\n\nvar CarouselConfig = function CarouselConfig() {\n  _classCallCheck(this, CarouselConfig);\n\n  /* Default interval of auto changing of slides */\n  this.interval = 5000;\n  /* Is loop of auto changing of slides can be paused */\n\n  this.noPause = false;\n  /* Is slides can wrap from the last to the first slide */\n\n  this.noWrap = false;\n  /* Show carousel-indicators */\n\n  this.showIndicators = true;\n  /* Slides can be paused on focus */\n\n  this.pauseOnFocus = false;\n  /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n\n  this.indicatorsByChunk = false;\n  /* If value more then 1 — carousel works in multilist mode */\n\n  this.itemsPerSlide = 1;\n  /* If `true` — carousel shifts by one element. By default carousel shifts by number\n      of visible elements (itemsPerSlide field) */\n\n  this.singleSlideOffset = false;\n};\n\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n  return new (t || CarouselConfig)();\n};\n/** @nocollapse */\n\n\nCarouselConfig.ɵprov = ɵɵdefineInjectable({\n  factory: function CarouselConfig_Factory() {\n    return new CarouselConfig();\n  },\n  token: CarouselConfig,\n  providedIn: \"root\"\n});\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CarouselConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\nif (false) {\n  /** @type {?} */\n  CarouselConfig.prototype.interval;\n  /** @type {?} */\n\n  CarouselConfig.prototype.noPause;\n  /** @type {?} */\n\n  CarouselConfig.prototype.noWrap;\n  /** @type {?} */\n\n  CarouselConfig.prototype.showIndicators;\n  /** @type {?} */\n\n  CarouselConfig.prototype.pauseOnFocus;\n  /** @type {?} */\n\n  CarouselConfig.prototype.indicatorsByChunk;\n  /** @type {?} */\n\n  CarouselConfig.prototype.itemsPerSlide;\n  /** @type {?} */\n\n  CarouselConfig.prototype.singleSlideOffset;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @template T\n * @param {?} array The source array to search in\n * @param {?} predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n * @return {?}\n */\n\n\nfunction findLastIndex(array, predicate) {\n  /** @type {?} */\n  var l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n/**\n * @template T\n * @param {?} array\n * @param {?} size\n * @return {?}\n */\n\n\nfunction chunkByNumber(array, size) {\n  /** @type {?} */\n  var out = [];\n  /** @type {?} */\n\n  var n = Math.ceil(array.length / size);\n  /** @type {?} */\n\n  var i = 0;\n\n  while (i < n) {\n    /** @type {?} */\n    var chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @enum {number} */\n\n\nvar Direction = {\n  UNKNOWN: 0,\n  NEXT: 1,\n  PREV: 2\n};\nDirection[Direction.UNKNOWN] = 'UNKNOWN';\nDirection[Direction.NEXT] = 'NEXT';\nDirection[Direction.PREV] = 'PREV';\n/**\n * Base element to create carousel\n */\n\nvar CarouselComponent = /*#__PURE__*/function () {\n  /**\n   * @param {?} config\n   * @param {?} ngZone\n   */\n  function CarouselComponent(config, ngZone) {\n    _classCallCheck(this, CarouselComponent);\n\n    this.ngZone = ngZone;\n    /* If `true` - carousel indicators indicate slides chunks\n         works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n         of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n    /**\n     * Turn on/off animation. Animation doesn't work for multilist carousel\n     */\n\n    this.isAnimated = false;\n    /**\n     * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n     */\n\n    this.activeSlideChange = new EventEmitter(false);\n    /**\n     * Will be emitted when active slides has been changed in multilist mode\n     */\n\n    this.slideRangeChange = new EventEmitter();\n    /* Index to start display slides from it */\n\n    this.startFromIndex = 0;\n    this._slides = new LinkedList();\n    this._currentVisibleSlidesIndex = 0;\n    this.destroyed = false;\n\n    this.getActive =\n    /**\n    * @param {?} slide\n    * @return {?}\n    */\n    function (slide) {\n      return slide.active;\n    };\n\n    this.makeSlidesConsistent =\n    /**\n    * @param {?} slides\n    * @return {?}\n    */\n    function (slides) {\n      slides.forEach(\n      /**\n      * @param {?} slide\n      * @param {?} index\n      * @return {?}\n      */\n      function (slide, index) {\n        return slide.item.order = index;\n      });\n    };\n\n    Object.assign(this, config);\n  }\n  /**\n   * Index of currently displayed slide(started for 0)\n   * @param {?} index\n   * @return {?}\n   */\n\n\n  _createClass(CarouselComponent, [{\n    key: \"activeSlide\",\n    get:\n    /**\n     * @return {?}\n     */\n    function get() {\n      return this._currentActiveSlide;\n    }\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     * @return {?}\n     */\n    ,\n    set: function set(index) {\n      if (this.multilist) {\n        return;\n      }\n\n      if (this._slides.length && index !== this._currentActiveSlide) {\n        this._select(index);\n      }\n    }\n  }, {\n    key: \"interval\",\n    get: function get() {\n      return this._interval;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    ,\n    set: function set(value) {\n      this._interval = value;\n      this.restartTimer();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"slides\",\n    get: function get() {\n      return this._slides.toArray();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"isBs4\",\n    get: function get() {\n      return !isBs3();\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      var _this = this;\n\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      function () {\n        if (_this.singleSlideOffset) {\n          _this.indicatorsByChunk = false;\n        }\n\n        if (_this.multilist) {\n          _this._chunkedSlides = chunkByNumber(_this.mapSlidesAndIndexes(), _this.itemsPerSlide);\n\n          _this.selectInitialSlides();\n        }\n      }, 0);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.destroyed = true;\n    }\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param {?} slide\n     * @return {?}\n     */\n\n  }, {\n    key: \"addSlide\",\n    value: function addSlide(slide) {\n      this._slides.add(slide);\n\n      if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n        slide.active = true;\n      }\n\n      if (!this.multilist && this.isAnimated) {\n        slide.isAnimated = true;\n      }\n\n      if (!this.multilist && this._slides.length === 1) {\n        this._currentActiveSlide = undefined;\n        this.activeSlide = 0;\n        this.play();\n      }\n\n      if (this.multilist && this._slides.length > this.itemsPerSlide) {\n        this.play();\n      }\n    }\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param {?} slide\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeSlide\",\n    value: function removeSlide(slide) {\n      var _this2 = this;\n\n      /** @type {?} */\n      var remIndex = this._slides.indexOf(slide);\n\n      if (this._currentActiveSlide === remIndex) {\n        // removing of active slide\n\n        /** @type {?} */\n        var nextSlideIndex = void 0;\n\n        if (this._slides.length > 1) {\n          // if this slide last - will roll to first slide, if noWrap flag is\n          // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n          // middle of collection, index of next slide is same to removed\n          nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n        }\n\n        this._slides.remove(remIndex); // prevents exception with changing some value after checking\n\n\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        function () {\n          _this2._select(nextSlideIndex);\n        }, 0);\n      } else {\n        this._slides.remove(remIndex);\n        /** @type {?} */\n\n\n        var currentSlideIndex = this.getCurrentSlideIndex();\n        setTimeout(\n        /**\n        * @return {?}\n        */\n        function () {\n          // after removing, need to actualize index of current active slide\n          _this2._currentActiveSlide = currentSlideIndex;\n\n          _this2.activeSlideChange.emit(_this2._currentActiveSlide);\n        }, 0);\n      }\n    }\n    /**\n     * @param {?=} force\n     * @return {?}\n     */\n\n  }, {\n    key: \"nextSlideFromInterval\",\n    value: function nextSlideFromInterval() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to next slide\n     * @param {?=} force\n     * @return {?}\n     */\n\n  }, {\n    key: \"nextSlide\",\n    value: function nextSlide() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.isPlaying) {\n        this.restartTimer();\n      }\n\n      this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to previous slide\n     * @param {?=} force\n     * @return {?}\n     */\n\n  }, {\n    key: \"previousSlide\",\n    value: function previousSlide() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.isPlaying) {\n        this.restartTimer();\n      }\n\n      this.move(Direction.PREV, force);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getFirstVisibleIndex\",\n    value: function getFirstVisibleIndex() {\n      return this.slides.findIndex(this.getActive);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"getLastVisibleIndex\",\n    value: function getLastVisibleIndex() {\n      return findLastIndex(this.slides, this.getActive);\n    }\n    /**\n     * @param {?} direction\n     * @param {?=} force\n     * @return {?}\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(direction) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      /** @type {?} */\n      var firstVisibleIndex = this.getFirstVisibleIndex();\n      /** @type {?} */\n\n      var lastVisibleIndex = this.getLastVisibleIndex();\n\n      if (this.noWrap) {\n        if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n          return;\n        }\n      }\n\n      if (!this.multilist) {\n        this.activeSlide = this.findNextSlideIndex(direction, force);\n      } else {\n        this.moveMultilist(direction);\n      }\n    }\n    /**\n     * Swith slides by enter, space and arrows keys\n     * \\@internal\n     * @param {?} event\n     * @return {?}\n     */\n\n  }, {\n    key: \"keydownPress\",\n    value: function keydownPress(event) {\n      // tslint:disable-next-line:deprecation\n      if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n        this.nextSlide();\n        event.preventDefault();\n        return;\n      } // tslint:disable-next-line:deprecation\n\n\n      if (event.keyCode === 37 || event.key === 'LeftArrow') {\n        this.previousSlide();\n        return;\n      } // tslint:disable-next-line:deprecation\n\n\n      if (event.keyCode === 39 || event.key === 'RightArrow') {\n        this.nextSlide();\n        return;\n      }\n    }\n    /**\n     * Play on mouse leave\n     * \\@internal\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave() {\n      if (!this.pauseOnFocus) {\n        this.play();\n      }\n    }\n    /**\n     * Play on mouse up\n     * \\@internal\n     * @return {?}\n     */\n\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      if (!this.pauseOnFocus) {\n        this.play();\n      }\n    }\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * \\@internal\n     * @return {?}\n     */\n\n  }, {\n    key: \"pauseFocusIn\",\n    value: function pauseFocusIn() {\n      if (this.pauseOnFocus) {\n        this.isPlaying = false;\n        this.resetTimer();\n      }\n    }\n    /**\n     * When slides out of focus autoplay is started\n     * \\@internal\n     * @return {?}\n     */\n\n  }, {\n    key: \"pauseFocusOut\",\n    value: function pauseFocusOut() {\n      this.play();\n    }\n    /**\n     * Rolling to specified slide\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"selectSlide\",\n    value: function selectSlide(index) {\n      if (this.isPlaying) {\n        this.restartTimer();\n      }\n\n      if (!this.multilist) {\n        this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n      } else {\n        this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n      }\n    }\n    /**\n     * Starts a auto changing of slides\n     * @return {?}\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (!this.isPlaying) {\n        this.isPlaying = true;\n        this.restartTimer();\n      }\n    }\n    /**\n     * Stops a auto changing of slides\n     * @return {?}\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (!this.noPause) {\n        this.isPlaying = false;\n        this.resetTimer();\n      }\n    }\n    /**\n     * Finds and returns index of currently displayed slide\n     * @return {?}\n     */\n\n  }, {\n    key: \"getCurrentSlideIndex\",\n    value: function getCurrentSlideIndex() {\n      return this._slides.findIndex(this.getActive);\n    }\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"isLast\",\n    value: function isLast(index) {\n      return index + 1 >= this._slides.length;\n    }\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"isFirst\",\n    value: function isFirst(index) {\n      return index === 0;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"indicatorsSlides\",\n    value: function indicatorsSlides() {\n      var _this3 = this;\n\n      return this.slides.filter(\n      /**\n      * @param {?} slide\n      * @param {?} index\n      * @return {?}\n      */\n      function (slide, index) {\n        return !_this3.indicatorsByChunk || index % _this3.itemsPerSlide === 0;\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"selectInitialSlides\",\n    value: function selectInitialSlides() {\n      /** @type {?} */\n      var startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n      this.hideSlides();\n\n      if (this.singleSlideOffset) {\n        this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n        if (this._slides.length - startIndex < this.itemsPerSlide) {\n          /** @type {?} */\n          var slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n          this._slidesWithIndexes = [].concat(_toConsumableArray(this._slidesWithIndexes), _toConsumableArray(slidesToAppend)).slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n        } else {\n          this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n        }\n\n        this._slidesWithIndexes.forEach(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.item.active = true;\n        });\n\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n      } else {\n        this.selectRangeByNestedIndex(startIndex);\n      }\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * Defines next slide index, depending of direction\n     * @private\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n\n  }, {\n    key: \"findNextSlideIndex\",\n    value: function findNextSlideIndex(direction, force) {\n      /** @type {?} */\n      var nextSlideIndex = 0;\n\n      if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n        return undefined;\n      }\n\n      switch (direction) {\n        case Direction.NEXT:\n          // if this is last slide, not force, looping is disabled\n          // and need to going forward - select current slide, as a next\n          nextSlideIndex = !this.isLast(this._currentActiveSlide) ? this._currentActiveSlide + 1 : !force && this.noWrap ? this._currentActiveSlide : 0;\n          break;\n\n        case Direction.PREV:\n          // if this is first slide, not force, looping is disabled\n          // and need to going backward - select current slide, as a next\n          nextSlideIndex = this._currentActiveSlide > 0 ? this._currentActiveSlide - 1 : !force && this.noWrap ? this._currentActiveSlide : this._slides.length - 1;\n          break;\n\n        default:\n          throw new Error('Unknown direction');\n      }\n\n      return nextSlideIndex;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"mapSlidesAndIndexes\",\n    value: function mapSlidesAndIndexes() {\n      return this.slides.slice().map(\n      /**\n      * @param {?} slide\n      * @param {?} index\n      * @return {?}\n      */\n      function (slide, index) {\n        return {\n          index: index,\n          item: slide\n        };\n      });\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"selectSlideRange\",\n    value: function selectSlideRange(index) {\n      if (this.isIndexInRange(index)) {\n        return;\n      }\n\n      this.hideSlides();\n\n      if (!this.singleSlideOffset) {\n        this.selectRangeByNestedIndex(index);\n      } else {\n        /** @type {?} */\n        var startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n        /** @type {?} */\n\n        var endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n        this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n\n        this._slidesWithIndexes.forEach(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.item.active = true;\n        });\n      }\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"selectRangeByNestedIndex\",\n    value: function selectRangeByNestedIndex(index) {\n      /** @type {?} */\n      var selectedRange = this._chunkedSlides.map(\n      /**\n      * @param {?} slidesList\n      * @param {?} i\n      * @return {?}\n      */\n      function (slidesList, i) {\n        return {\n          index: i,\n          list: slidesList\n        };\n      }).find(\n      /**\n      * @param {?} slidesList\n      * @return {?}\n      */\n      function (slidesList) {\n        return slidesList.list.find(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.index === index;\n        }) !== undefined;\n      });\n\n      this._currentVisibleSlidesIndex = selectedRange.index;\n\n      this._chunkedSlides[selectedRange.index].forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      function (slide) {\n        slide.item.active = true;\n      });\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"isIndexOnTheEdges\",\n    value: function isIndexOnTheEdges(index) {\n      return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n    }\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"isIndexInRange\",\n    value: function isIndexInRange(index) {\n      if (this.singleSlideOffset) {\n        /** @type {?} */\n        var visibleIndexes = this._slidesWithIndexes.map(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.index;\n        });\n\n        return visibleIndexes.indexOf(index) >= 0;\n      }\n\n      return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"hideSlides\",\n    value: function hideSlides() {\n      this.slides.forEach(\n      /**\n      * @param {?} slide\n      * @return {?}\n      */\n      function (slide) {\n        return slide.active = false;\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"isVisibleSlideListLast\",\n    value: function isVisibleSlideListLast() {\n      return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"isVisibleSlideListFirst\",\n    value: function isVisibleSlideListFirst() {\n      return this._currentVisibleSlidesIndex === 0;\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n\n  }, {\n    key: \"moveSliderByOneItem\",\n    value: function moveSliderByOneItem(direction) {\n      /** @type {?} */\n      var firstVisibleIndex;\n      /** @type {?} */\n\n      var lastVisibleIndex;\n      /** @type {?} */\n\n      var indexToHide;\n      /** @type {?} */\n\n      var indexToShow;\n\n      if (this.noWrap) {\n        firstVisibleIndex = this.getFirstVisibleIndex();\n        lastVisibleIndex = this.getLastVisibleIndex();\n        indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n        indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n        this._slides.get(indexToHide).active = false;\n        this._slides.get(indexToShow).active = true;\n        /** @type {?} */\n\n        var slidesToReorder = this.mapSlidesAndIndexes().filter(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.item.active;\n        });\n        this.makeSlidesConsistent(slidesToReorder);\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n      } else {\n        /** @type {?} */\n        var displayedIndex;\n        firstVisibleIndex = this._slidesWithIndexes[0].index;\n        lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n        if (direction === Direction.NEXT) {\n          this._slidesWithIndexes.shift();\n\n          displayedIndex = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n\n          this._slidesWithIndexes.push({\n            index: displayedIndex,\n            item: this._slides.get(displayedIndex)\n          });\n        } else {\n          this._slidesWithIndexes.pop();\n\n          displayedIndex = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n          this._slidesWithIndexes = [{\n            index: displayedIndex,\n            item: this._slides.get(displayedIndex)\n          }].concat(_toConsumableArray(this._slidesWithIndexes));\n        }\n\n        this.hideSlides();\n\n        this._slidesWithIndexes.forEach(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.item.active = true;\n        });\n\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n        this.slideRangeChange.emit(this._slidesWithIndexes.map(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.index;\n        }));\n      }\n    }\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n\n  }, {\n    key: \"moveMultilist\",\n    value: function moveMultilist(direction) {\n      if (this.singleSlideOffset) {\n        this.moveSliderByOneItem(direction);\n      } else {\n        this.hideSlides();\n\n        if (this.noWrap) {\n          this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n        } else {\n          if (direction === Direction.NEXT) {\n            this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n          } else {\n            this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst() ? this._chunkedSlides.length - 1 : this._currentVisibleSlidesIndex - 1;\n          }\n        }\n\n        this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.item.active = true;\n        });\n\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"getVisibleIndexes\",\n    value: function getVisibleIndexes() {\n      if (!this.singleSlideOffset) {\n        return this._chunkedSlides[this._currentVisibleSlidesIndex].map(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.index;\n        });\n      } else {\n        return this._slidesWithIndexes.map(\n        /**\n        * @param {?} slide\n        * @return {?}\n        */\n        function (slide) {\n          return slide.index;\n        });\n      }\n    }\n    /**\n     * Sets a slide, which specified through index, as active\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"_select\",\n    value: function _select(index) {\n      if (isNaN(index)) {\n        this.pause();\n        return;\n      }\n\n      if (!this.multilist) {\n        /** @type {?} */\n        var currentSlide = this._slides.get(this._currentActiveSlide);\n\n        if (currentSlide) {\n          currentSlide.active = false;\n        }\n      }\n      /** @type {?} */\n\n\n      var nextSlide = this._slides.get(index);\n\n      if (nextSlide) {\n        this._currentActiveSlide = index;\n        nextSlide.active = true;\n        this.activeSlide = index;\n        this.activeSlideChange.emit(index);\n      }\n    }\n    /**\n     * Starts loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"restartTimer\",\n    value: function restartTimer() {\n      var _this4 = this;\n\n      this.resetTimer();\n      /** @type {?} */\n\n      var interval = +this.interval;\n\n      if (!isNaN(interval) && interval > 0) {\n        this.currentInterval = this.ngZone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          return setInterval(\n          /**\n          * @return {?}\n          */\n          function () {\n            /** @type {?} */\n            var nInterval = +_this4.interval;\n\n            _this4.ngZone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              if (_this4.isPlaying && !isNaN(_this4.interval) && nInterval > 0 && _this4.slides.length) {\n                _this4.nextSlideFromInterval();\n              } else {\n                _this4.pause();\n              }\n            });\n          }, interval);\n        });\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"multilist\",\n    get: function get() {\n      return this.itemsPerSlide > 1;\n    }\n    /**\n     * Stops loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"resetTimer\",\n    value: function resetTimer() {\n      if (this.currentInterval) {\n        clearInterval(this.currentInterval);\n        this.currentInterval = void 0;\n      }\n    }\n  }]);\n\n  return CarouselComponent;\n}();\n\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n  return new (t || CarouselComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n};\n\nCarouselComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: CarouselComponent,\n  selectors: [[\"carousel\"]],\n  inputs: {\n    indicatorsByChunk: \"indicatorsByChunk\",\n    itemsPerSlide: \"itemsPerSlide\",\n    singleSlideOffset: \"singleSlideOffset\",\n    isAnimated: \"isAnimated\",\n    startFromIndex: \"startFromIndex\",\n    activeSlide: \"activeSlide\",\n    interval: \"interval\",\n    noWrap: \"noWrap\",\n    noPause: \"noPause\",\n    showIndicators: \"showIndicators\",\n    pauseOnFocus: \"pauseOnFocus\"\n  },\n  outputs: {\n    activeSlideChange: \"activeSlideChange\",\n    slideRangeChange: \"slideRangeChange\"\n  },\n  ngContentSelectors: _c1,\n  decls: 6,\n  vars: 6,\n  consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [\"class\", \"carousel-indicators\", 4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [\"class\", \"sr-only\", 4, \"ngIf\"], [1, \"sr-only\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n  template: function CarouselComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n      ɵngcc0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n        return ctx.pause();\n      })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n        return ctx.onMouseLeave();\n      })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n        return ctx.onMouseUp();\n      })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n        return ctx.keydownPress($event);\n      })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n        return ctx.pauseFocusIn();\n      })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n        return ctx.pauseFocusOut();\n      });\n      ɵngcc0.ɵɵtemplate(1, CarouselComponent_ol_1_Template, 2, 1, \"ol\", 1);\n      ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n      ɵngcc0.ɵɵprojection(3);\n      ɵngcc0.ɵɵelementEnd();\n      ɵngcc0.ɵɵtemplate(4, CarouselComponent_a_4_Template, 3, 3, \"a\", 3);\n      ɵngcc0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 4, 2, \"a\", 4);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showIndicators && ctx.slides.length > 1);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(4, _c0, ctx.multilist ? \"flex\" : \"block\"));\n      ɵngcc0.ɵɵadvance(2);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      ɵngcc0.ɵɵadvance(1);\n      ɵngcc0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    }\n  },\n  directives: [ɵngcc1.NgIf, ɵngcc1.NgStyle, ɵngcc1.NgForOf],\n  encapsulation: 2\n});\n/** @nocollapse */\n\nCarouselComponent.ctorParameters = function () {\n  return [{\n    type: CarouselConfig\n  }, {\n    type: NgZone\n  }];\n};\n\nCarouselComponent.propDecorators = {\n  noWrap: [{\n    type: Input\n  }],\n  noPause: [{\n    type: Input\n  }],\n  showIndicators: [{\n    type: Input\n  }],\n  pauseOnFocus: [{\n    type: Input\n  }],\n  indicatorsByChunk: [{\n    type: Input\n  }],\n  itemsPerSlide: [{\n    type: Input\n  }],\n  singleSlideOffset: [{\n    type: Input\n  }],\n  isAnimated: [{\n    type: Input\n  }],\n  activeSlideChange: [{\n    type: Output\n  }],\n  slideRangeChange: [{\n    type: Output\n  }],\n  activeSlide: [{\n    type: Input\n  }],\n  startFromIndex: [{\n    type: Input\n  }],\n  interval: [{\n    type: Input\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CarouselComponent, [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ol class=\\\"carousel-indicators\\\" *ngIf=\\\"showIndicators && slides.length > 1\\\">\\n    <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\">\\n    </li>\\n  </ol>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     [class.disabled]=\\\"activeSlide === 0 && noWrap\\\"\\n     (click)=\\\"previousSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     [class.disabled]=\\\"isLast(activeSlide) && noWrap\\\"\\n     (click)=\\\"nextSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only\\\">Next</span>\\n  </a>\\n</div>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: CarouselConfig\n    }, {\n      type: ɵngcc0.NgZone\n    }];\n  }, {\n    indicatorsByChunk: [{\n      type: Input\n    }],\n    itemsPerSlide: [{\n      type: Input\n    }],\n    singleSlideOffset: [{\n      type: Input\n    }],\n    isAnimated: [{\n      type: Input\n    }],\n    activeSlideChange: [{\n      type: Output\n    }],\n    slideRangeChange: [{\n      type: Output\n    }],\n    startFromIndex: [{\n      type: Input\n    }],\n    activeSlide: [{\n      type: Input\n    }],\n    interval: [{\n      type: Input\n    }],\n    noWrap: [{\n      type: Input\n    }],\n    noPause: [{\n      type: Input\n    }],\n    showIndicators: [{\n      type: Input\n    }],\n    pauseOnFocus: [{\n      type: Input\n    }]\n  });\n})();\n\nif (false) {\n  /** @type {?} */\n  CarouselComponent.prototype.noWrap;\n  /** @type {?} */\n\n  CarouselComponent.prototype.noPause;\n  /** @type {?} */\n\n  CarouselComponent.prototype.showIndicators;\n  /** @type {?} */\n\n  CarouselComponent.prototype.pauseOnFocus;\n  /** @type {?} */\n\n  CarouselComponent.prototype.indicatorsByChunk;\n  /** @type {?} */\n\n  CarouselComponent.prototype.itemsPerSlide;\n  /** @type {?} */\n\n  CarouselComponent.prototype.singleSlideOffset;\n  /**\n   * Turn on/off animation. Animation doesn't work for multilist carousel\n   * @type {?}\n   */\n\n  CarouselComponent.prototype.isAnimated;\n  /**\n   * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n   * @type {?}\n   */\n\n  CarouselComponent.prototype.activeSlideChange;\n  /**\n   * Will be emitted when active slides has been changed in multilist mode\n   * @type {?}\n   */\n\n  CarouselComponent.prototype.slideRangeChange;\n  /** @type {?} */\n\n  CarouselComponent.prototype.startFromIndex;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype.currentInterval;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._currentActiveSlide;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._interval;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._slides;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._chunkedSlides;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._slidesWithIndexes;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype._currentVisibleSlidesIndex;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype.isPlaying;\n  /**\n   * @type {?}\n   * @protected\n   */\n\n  CarouselComponent.prototype.destroyed;\n  /** @type {?} */\n\n  CarouselComponent.prototype.getActive;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CarouselComponent.prototype.makeSlidesConsistent;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  CarouselComponent.prototype.ngZone;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar SlideComponent = /*#__PURE__*/function () {\n  /**\n   * @param {?} carousel\n   */\n  function SlideComponent(carousel) {\n    _classCallCheck(this, SlideComponent);\n\n    this.itemWidth = '100%';\n    this.order = 0;\n    /**\n     * Wraps element by appropriate CSS classes\n     */\n\n    this.addClass = true;\n    this.carousel = carousel;\n  }\n  /**\n   * Fires changes in container collection after adding a new slide instance\n   * @return {?}\n   */\n\n\n  _createClass(SlideComponent, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      this.carousel.addSlide(this);\n      this.itemWidth = \"\".concat(100 / this.carousel.itemsPerSlide, \"%\");\n    }\n    /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.carousel.removeSlide(this);\n    }\n  }]);\n\n  return SlideComponent;\n}();\n\nSlideComponent.ɵfac = function SlideComponent_Factory(t) {\n  return new (t || SlideComponent)(ɵngcc0.ɵɵdirectiveInject(CarouselComponent));\n};\n\nSlideComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n  type: SlideComponent,\n  selectors: [[\"slide\"]],\n  hostVars: 13,\n  hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      ɵngcc0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n      ɵngcc0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n      ɵngcc0.ɵɵclassProp(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated);\n    }\n  },\n  inputs: {\n    active: \"active\"\n  },\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[1, \"item\"]],\n  template: function SlideComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵprojectionDef();\n      ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n      ɵngcc0.ɵɵprojection(1);\n      ɵngcc0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵclassProp(\"active\", ctx.active);\n    }\n  },\n  styles: [\".carousel-animation[_nghost-%COMP%] {\\n       transition: opacity 0.6s ease, visibility 0.6s ease;\\n       float: left;\\n    }\\n    .carousel-animation.active[_nghost-%COMP%] {\\n      opacity: 1;\\n      visibility: visible;\\n    }\\n    .carousel-animation[_nghost-%COMP%]:not(.active) {\\n      display: block;\\n      position: absolute;\\n      opacity: 0;\\n      visibility: hidden;\\n    }\"]\n});\n/** @nocollapse */\n\nSlideComponent.ctorParameters = function () {\n  return [{\n    type: CarouselComponent\n  }];\n};\n\nSlideComponent.propDecorators = {\n  active: [{\n    type: HostBinding,\n    args: ['class.active']\n  }, {\n    type: Input\n  }],\n  itemWidth: [{\n    type: HostBinding,\n    args: ['style.width']\n  }],\n  order: [{\n    type: HostBinding,\n    args: ['style.order']\n  }],\n  isAnimated: [{\n    type: HostBinding,\n    args: ['class.carousel-animation']\n  }],\n  addClass: [{\n    type: HostBinding,\n    args: ['class.item']\n  }, {\n    type: HostBinding,\n    args: ['class.carousel-item']\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(SlideComponent, [{\n    type: Component,\n    args: [{\n      selector: 'slide',\n      template: \"\\n    <div [class.active]=\\\"active\\\" class=\\\"item\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  \",\n      host: {\n        '[attr.aria-hidden]': '!active'\n      },\n      styles: [\"\\n    :host.carousel-animation {\\n       transition: opacity 0.6s ease, visibility 0.6s ease;\\n       float: left;\\n    }\\n    :host.carousel-animation.active {\\n      opacity: 1;\\n      visibility: visible;\\n    }\\n    :host.carousel-animation:not(.active) {\\n      display: block;\\n      position: absolute;\\n      opacity: 0;\\n      visibility: hidden;\\n    }\\n  \"]\n    }]\n  }], function () {\n    return [{\n      type: CarouselComponent\n    }];\n  }, {\n    itemWidth: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    order: [{\n      type: HostBinding,\n      args: ['style.order']\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.item']\n    }, {\n      type: HostBinding,\n      args: ['class.carousel-item']\n    }],\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }],\n    isAnimated: [{\n      type: HostBinding,\n      args: ['class.carousel-animation']\n    }]\n  });\n})();\n\nif (false) {\n  /**\n   * Is current slide active\n   * @type {?}\n   */\n  SlideComponent.prototype.active;\n  /** @type {?} */\n\n  SlideComponent.prototype.itemWidth;\n  /** @type {?} */\n\n  SlideComponent.prototype.order;\n  /** @type {?} */\n\n  SlideComponent.prototype.isAnimated;\n  /**\n   * Wraps element by appropriate CSS classes\n   * @type {?}\n   */\n\n  SlideComponent.prototype.addClass;\n  /**\n   * Link to Parent(container-collection) component\n   * @type {?}\n   * @protected\n   */\n\n  SlideComponent.prototype.carousel;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar CarouselModule = /*#__PURE__*/function () {\n  function CarouselModule() {\n    _classCallCheck(this, CarouselModule);\n  }\n\n  _createClass(CarouselModule, null, [{\n    key: \"forRoot\",\n    value:\n    /**\n     * @return {?}\n     */\n    function forRoot() {\n      return {\n        ngModule: CarouselModule,\n        providers: []\n      };\n    }\n  }]);\n\n  return CarouselModule;\n}();\n\nCarouselModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: CarouselModule\n});\nCarouselModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function CarouselModule_Factory(t) {\n    return new (t || CarouselModule)();\n  },\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CarouselModule, {\n    declarations: function declarations() {\n      return [SlideComponent, CarouselComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [SlideComponent, CarouselComponent];\n    }\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(CarouselModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SlideComponent, CarouselComponent],\n      exports: [SlideComponent, CarouselComponent]\n    }]\n  }], null, null);\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };","map":{"version":3,"sources":["ngx-bootstrap/carousel/carousel.config.ts","ngx-bootstrap/carousel/utils.ts","ngx-bootstrap/carousel/carousel.component.ts","ngx-bootstrap/carousel/slide.component.ts","ngx-bootstrap/carousel/carousel.module.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CarouselConfig {\n  /* Default interval of auto changing of slides */\n  interval = 5000;\n\n  /* Is loop of auto changing of slides can be paused */\n  noPause = false;\n\n  /* Is slides can wrap from the last to the first slide */\n  noWrap = false;\n\n  /* Show carousel-indicators */\n  showIndicators = true;\n\n  /* Slides can be paused on focus */\n  pauseOnFocus = false;\n\n  /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n  indicatorsByChunk = false;\n\n  /* If value more then 1 — carousel works in multilist mode */\n  itemsPerSlide = 1;\n\n  /* If `true` — carousel shifts by one element. By default carousel shifts by number\n    of visible elements (itemsPerSlide field) */\n  singleSlideOffset = false;\n}\n","/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nexport function findLastIndex<T>(array: T[], predicate: (value: T, index: number, obj: T[]) => boolean): number {\n  let l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n\nexport function chunkByNumber<T>(array: T[], size: number): T[][] {\n  const out = [];\n  const n = Math.ceil((array.length) / size);\n  let i = 0;\n\n  while (i < n) {\n    const chunk = array.splice(\n      0,\n      (i === n - 1) && size < array.length ? array.length : size\n    );\n\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n","// tslint:disable:max-file-line-count\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\n\nimport {\n  Component, EventEmitter, Input, NgZone, OnDestroy, Output, AfterViewInit\n} from '@angular/core';\n\nimport { isBs3, LinkedList } from 'ngx-bootstrap/utils';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\nimport { findLastIndex, chunkByNumber } from './utils';\nimport { SlideWithIndex, IndexedSlideList } from './models';\n\nexport enum Direction {\n  UNKNOWN,\n  NEXT,\n  PREV\n}\n\n/**\n * Base element to create carousel\n */\n@Component({\n  selector: 'carousel',\n  templateUrl: './carousel.component.html'\n})\nexport class CarouselComponent implements AfterViewInit, OnDestroy {\n  /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n  @Input() noWrap: boolean;\n  /*  If `true` — will disable pausing on carousel mouse hover */\n  @Input() noPause: boolean;\n  /*  If `true` — carousel-indicators are visible  */\n  @Input() showIndicators: boolean;\n  /*  If `true` - autoplay will be stopped on focus */\n  @Input() pauseOnFocus: boolean;\n  /* If `true` - carousel indicators indicate slides chunks\n     works ONLY if singleSlideOffset = FALSE */\n  @Input() indicatorsByChunk = false;\n  /* If value more then 1 — carousel works in multilist mode */\n  @Input() itemsPerSlide = 1;\n  /* If `true` — carousel shifts by one element. By default carousel shifts by number\n     of visible elements (itemsPerSlide field) */\n  @Input() singleSlideOffset = false;\n  /** Turn on/off animation. Animation doesn't work for multilist carousel */\n  @Input() isAnimated = false;\n\n  /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n  @Output()\n  activeSlideChange: EventEmitter<number> = new EventEmitter<number>(false);\n\n  /** Will be emitted when active slides has been changed in multilist mode */\n  @Output()\n  slideRangeChange: EventEmitter<number[]> = new EventEmitter<number[]>();\n\n  /** Index of currently displayed slide(started for 0) */\n  @Input()\n  set activeSlide(index: number) {\n    if (this.multilist) {\n      return;\n    }\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n\n  get activeSlide(): number {\n    return this._currentActiveSlide;\n  }\n\n  /* Index to start display slides from it */\n  @Input()\n  startFromIndex = 0;\n\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n  @Input()\n  get interval(): number {\n    return this._interval;\n  }\n\n  set interval(value: number) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  get slides(): SlideComponent[] {\n    return this._slides.toArray();\n  }\n\n  // tslint:disable-next-line:no-any\n  protected currentInterval: any;\n  protected _currentActiveSlide: number;\n  protected _interval: number;\n  protected _slides: LinkedList<SlideComponent> = new LinkedList<SlideComponent>();\n  protected _chunkedSlides: SlideWithIndex[][];\n  protected _slidesWithIndexes: SlideWithIndex[];\n  protected _currentVisibleSlidesIndex = 0;\n  protected isPlaying: boolean;\n  protected destroyed = false;\n\n  get isBs4(): boolean {\n    return !isBs3();\n  }\n\n  constructor(config: CarouselConfig, private ngZone: NgZone) {\n    Object.assign(this, config);\n  }\n\n  ngAfterViewInit(): void {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(\n          this.mapSlidesAndIndexes(),\n          this.itemsPerSlide\n        );\n        this.selectInitialSlides();\n      }\n    }, 0);\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed = true;\n  }\n\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n  addSlide(slide: SlideComponent): void {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      this.activeSlide = 0;\n      this.play();\n    }\n\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n  removeSlide(slide: SlideComponent): void {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex: number = void 0;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex)\n          ? remIndex\n          : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n\n  nextSlideFromInterval(force = false): void {\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  nextSlide(force = false): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  previousSlide(force = false): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n    this.move(Direction.PREV, force);\n  }\n\n  getFirstVisibleIndex(): number {\n    return this.slides.findIndex(this.getActive);\n  }\n\n  getLastVisibleIndex(): number {\n    return findLastIndex(this.slides, this.getActive);\n  }\n\n  getActive = (slide: SlideComponent) => slide.active;\n\n  move(direction: Direction, force = false): void {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (\n        direction === Direction.NEXT &&\n        this.isLast(lastVisibleIndex) ||\n        direction === Direction.PREV &&\n        firstVisibleIndex === 0\n      ) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force);\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n\n  /**\n   * Swith slides by enter, space and arrows keys\n   * @internal\n   */\n  keydownPress(event: KeyboardEvent) {\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n\n      return;\n    }\n\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n\n      return;\n    }\n\n    // tslint:disable-next-line:deprecation\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n\n      return;\n    }\n  }\n\n  /**\n   * Play on mouse leave\n   * @internal\n   */\n  onMouseLeave(): void {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n\n  /**\n   * Play on mouse up\n   * @internal\n   */\n  onMouseUp(): void {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * @internal\n   */\n  pauseFocusIn(): void {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * When slides out of focus autoplay is started\n   * @internal\n   */\n  pauseFocusOut(): void {\n    this.play();\n  }\n\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  selectSlide(index: number): void {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n\n  /**\n   * Starts a auto changing of slides\n   */\n  play(): void {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n\n  /**\n   * Stops a auto changing of slides\n   */\n  pause(): void {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n  getCurrentSlideIndex(): number {\n    return this._slides.findIndex(this.getActive);\n  }\n\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n  isLast(index: number): boolean {\n    return index + 1 >= this._slides.length;\n  }\n\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n  isFirst(index: number): boolean {\n    return index === 0;\n  }\n\n  indicatorsSlides(): SlideComponent[] {\n    return this.slides.filter(\n      (slide: SlideComponent, index: number) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0\n    );\n  }\n\n  private selectInitialSlides(): void {\n    const startIndex = this.startFromIndex <= this._slides.length\n      ? this.startFromIndex\n      : 0;\n\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes  = [\n          ...this._slidesWithIndexes,\n          ...slidesToAppend\n        ]\n          .slice(slidesToAppend.length)\n          .slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(\n          startIndex,\n          startIndex + this.itemsPerSlide\n        );\n      }\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n  private findNextSlideIndex(direction: Direction, force: boolean): number {\n    let nextSlideIndex = 0;\n\n    if (\n      !force &&\n      (this.isLast(this.activeSlide) &&\n        direction !== Direction.PREV &&\n        this.noWrap)\n    ) {\n      return undefined;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        nextSlideIndex = !this.isLast(this._currentActiveSlide)\n          ? this._currentActiveSlide + 1\n          : !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        nextSlideIndex =\n          this._currentActiveSlide > 0\n            ? this._currentActiveSlide - 1\n            : !force && this.noWrap\n              ? this._currentActiveSlide\n              : this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n\n  private mapSlidesAndIndexes(): SlideWithIndex[] {\n    return this.slides\n      .slice()\n      .map((slide: SlideComponent, index: number) => {\n        return {\n          index,\n          item: slide\n        };\n      });\n  }\n\n\n  private selectSlideRange(index: number): void {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index)\n        ? index\n        : index - this.itemsPerSlide + 1;\n\n      const endIndex = this.isIndexOnTheEdges(index)\n        ? index + this.itemsPerSlide\n        : index + 1;\n\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  private selectRangeByNestedIndex(index: number): void {\n    const selectedRange = this._chunkedSlides\n      .map((slidesList, i: number) => {\n        return {\n          index: i,\n          list: slidesList\n        };\n      })\n      .find(\n        (slidesList: IndexedSlideList) => {\n          return slidesList.list.find(slide => slide.index === index) !== undefined;\n        }\n      );\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach((slide: SlideWithIndex) => {\n      slide.item.active = true;\n    });\n  }\n\n  private isIndexOnTheEdges(index: number): boolean {\n    return (\n      index + 1 - this.itemsPerSlide <= 0 ||\n      index + this.itemsPerSlide <= this._slides.length\n    );\n  }\n\n  private isIndexInRange(index: number): boolean {\n    if (this.singleSlideOffset) {\n      const visibleIndexes = this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return (\n      index <= this.getLastVisibleIndex() &&\n      index >= this.getFirstVisibleIndex()\n    );\n  }\n\n  private hideSlides(): void {\n    this.slides.forEach((slide: SlideComponent) => slide.active = false);\n  }\n\n  private isVisibleSlideListLast(): boolean {\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n\n  private isVisibleSlideListFirst(): boolean {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n\n  private moveSliderByOneItem(direction: Direction): void {\n    let firstVisibleIndex: number;\n    let lastVisibleIndex: number;\n    let indexToHide: number;\n    let indexToShow: number;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n\n      indexToHide = direction === Direction.NEXT\n        ? firstVisibleIndex\n        : lastVisibleIndex;\n\n      indexToShow = direction !== Direction.NEXT\n        ? firstVisibleIndex - 1\n        : !this.isLast(lastVisibleIndex)\n          ? lastVisibleIndex + 1 : 0;\n\n      this._slides.get(indexToHide).active = false;\n      this._slides.get(indexToShow).active = true;\n\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(\n        (slide: SlideWithIndex) => slide.item.active\n      );\n\n      this.makeSlidesConsistent(slidesToReorder);\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    } else {\n      let displayedIndex: number;\n\n      firstVisibleIndex = this._slidesWithIndexes[0].index;\n      lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n      if (direction === Direction.NEXT) {\n        this._slidesWithIndexes.shift();\n\n        displayedIndex = this.isLast(lastVisibleIndex)\n          ? 0\n          : lastVisibleIndex + 1;\n\n        this._slidesWithIndexes.push({\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        });\n      } else {\n        this._slidesWithIndexes.pop();\n        displayedIndex = this.isFirst(firstVisibleIndex)\n          ? this._slides.length - 1\n          : firstVisibleIndex - 1;\n\n        this._slidesWithIndexes = [{\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        }, ...this._slidesWithIndexes];\n      }\n\n      this.hideSlides();\n\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this.slideRangeChange.emit(\n        this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index)\n      );\n    }\n  }\n\n  private makeSlidesConsistent = (slides: SlideWithIndex[]): void => {\n    slides.forEach((slide: SlideWithIndex, index: number) => slide.item.order = index);\n  }\n\n  private moveMultilist(direction: Direction): void {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT\n          ? this._currentVisibleSlidesIndex + 1\n          : this._currentVisibleSlidesIndex - 1;\n      } else {\n        if (direction === Direction.NEXT) {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n            ? 0\n            : this._currentVisibleSlidesIndex + 1;\n        } else {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst()\n            ? this._chunkedSlides.length - 1\n            : this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n        (slide: SlideWithIndex) => slide.item.active = true\n      );\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n\n  private getVisibleIndexes(): number[] {\n    if (!this.singleSlideOffset) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex]\n        .map((slide: SlideWithIndex) => slide.index);\n    } else {\n      return this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n    }\n  }\n\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n  private _select(index: number): void {\n    if (isNaN(index)) {\n      this.pause();\n\n      return;\n    }\n\n    if (!this.multilist) {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n      if (currentSlide) {\n        currentSlide.active = false;\n      }\n    }\n\n    const nextSlide = this._slides.get(index);\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n\n  /**\n   * Starts loop of auto changing of slides\n   */\n  private restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (\n              this.isPlaying &&\n              !isNaN(this.interval) &&\n              nInterval > 0 &&\n              this.slides.length\n            ) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n\n  get multilist(): boolean {\n    return this.itemsPerSlide > 1;\n  }\n\n  /**\n   * Stops loop of auto changing of slides\n   */\n  private resetTimer(): void {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n}\n","import {\n  Component,\n  HostBinding,\n  OnDestroy,\n  Input,\n  OnInit\n} from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\n\n@Component({\n  selector: 'slide',\n  template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n  host: {\n    '[attr.aria-hidden]': '!active'\n  },\n  styles: [`\n    :host.carousel-animation {\n       transition: opacity 0.6s ease, visibility 0.6s ease;\n       float: left;\n    }\n    :host.carousel-animation.active {\n      opacity: 1;\n      visibility: visible;\n    }\n    :host.carousel-animation:not(.active) {\n      display: block;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n    }\n  `]\n})\nexport class SlideComponent implements OnInit, OnDestroy {\n  /** Is current slide active */\n  @HostBinding('class.active')\n  @Input()\n  active: boolean;\n\n  @HostBinding('style.width') itemWidth = '100%';\n  @HostBinding('style.order') order = 0;\n  @HostBinding('class.carousel-animation') isAnimated: boolean;\n\n  /** Wraps element by appropriate CSS classes */\n  @HostBinding('class.item')\n  @HostBinding('class.carousel-item')\n  addClass = true;\n\n  /** Link to Parent(container-collection) component */\n  protected carousel: CarouselComponent;\n\n  constructor(carousel: CarouselComponent) {\n    this.carousel = carousel;\n  }\n\n  /** Fires changes in container collection after adding a new slide instance */\n  ngOnInit(): void {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n  }\n\n  /** Fires changes in container collection after removing of this slide instance */\n  ngOnDestroy(): void {\n    this.carousel.removeSlide(this);\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule, ModuleWithProviders } from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\nimport { SlideComponent } from './slide.component';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [SlideComponent, CarouselComponent],\n  exports: [SlideComponent, CarouselComponent]\n})\nexport class CarouselModule {\n  static forRoot(): ModuleWithProviders<CarouselModule> {\n    return { ngModule: CarouselModule, providers: [] };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}