{"ast":null,"code":"import _classCallCheck from \"/home/knoldus/Projects/cockpit-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/knoldus/Projects/cockpit-frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"/home/knoldus/Projects/cockpit-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport { Injectable, NgZone, RendererFactory2, Inject, PLATFORM_ID, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Get CSS computed property of the given element\n * @param {?} element\n * @param {?=} property\n * @return {?}\n */\n\nimport * as Éµngcc0 from '@angular/core';\n\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  } // NOTE: 1 DOM access here\n\n  /** @type {?} */\n\n\n  var window = element.ownerDocument.defaultView;\n  /** @type {?} */\n\n  var css = window.getComputedStyle(element, null);\n  return property ? css[\n  /** @type {?} */\n  property] : css;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Returns the parentNode or the host of the element\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n\n    case '#document':\n      return element.body;\n\n    default:\n  } // Firefox want us to check `-x` and `-y` variations as well\n\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nvar isIE11 = isBrowser && !!(\n/** @type {?} */\nwindow.MSInputMethodContext &&\n/** @type {?} */\ndocument.documentMode);\n/** @type {?} */\n\nvar isIE10 = isBrowser && !!(\n/** @type {?} */\nwindow.MSInputMethodContext && /MSIE 10/.test(\n/** @type {?} */\nnavigator.userAgent));\n/**\n * @param {?=} version\n * @return {?}\n */\n\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n  /** @type {?} */\n\n\n  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here\n\n  /** @type {?} */\n\n  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent\n\n  /** @type {?} */\n\n  var sibling;\n\n  while (offsetParent === noOffsetParent && element.nextElementSibling && sibling !== element.nextElementSibling) {\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n  /** @type {?} */\n\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  } // .offsetParent will return the closest TH, TD or TABLE in case\n\n\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @param {?} node\n * @return {?}\n */\n\n\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element1\n * @param {?} element2\n * @return {?}\n */\n\n\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  } // Here we make sure to give as \"start\" the element that comes first in the DOM\n\n  /* tslint:disable-next-line: no-bitwise */\n\n  /** @type {?} */\n\n\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  /** @type {?} */\n\n  var start = order ? element1 : element2;\n  /** @type {?} */\n\n  var end = order ? element2 : element1; // Get common ancestor container\n\n  /** @type {?} */\n\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  } // one of the nodes is inside shadowDOM, find which one\n\n  /** @type {?} */\n\n\n  var element1root = getRoot(element1);\n\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Helper to detect borders of a given element\n */\n\n/**\n * @param {?} styles\n * @param {?} axis\n * @return {?}\n */\n\n\nfunction getBordersSize(styles, axis) {\n  /** @type {?} */\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  /** @type {?} */\n\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles[\n  /** @type {?} */\n  \"border\".concat(sideA, \"Width\")]) + parseFloat(styles[\n  /** @type {?} */\n  \"border\".concat(sideB, \"Width\")]);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} axis\n * @param {?} body\n * @param {?} html\n * @param {?} computedStyle\n * @return {?}\n */\n\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n  /** @type {?} */\n  body[\"offset\".concat(axis)],\n  /** @type {?} */\n  body[\"scroll\".concat(axis)],\n  /** @type {?} */\n  html[\"client\".concat(axis)],\n  /** @type {?} */\n  html[\"offset\".concat(axis)],\n  /** @type {?} */\n  html[\"scroll\".concat(axis)], isIE(10) ? parseInt(\n  /** @type {?} */\n  html[\"offset\".concat(axis)], 10) + parseInt(computedStyle[\n  /** @type {?} */\n  \"margin\".concat(axis === 'Height' ? 'Top' : 'Left')], 10) + parseInt(computedStyle[\n  /** @type {?} */\n  \"margin\".concat(axis === 'Height' ? 'Bottom' : 'Right')], 10) : 0);\n}\n/**\n * @param {?} document\n * @return {?}\n */\n\n\nfunction getWindowSizes(document) {\n  /** @type {?} */\n  var body = document.body;\n  /** @type {?} */\n\n  var html = document.documentElement;\n  /** @type {?} */\n\n  var computedStyle = isIE(10) && getComputedStyle(html);\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @param {?} element\n * @param {?=} side\n * @return {?}\n */\n\n\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  /** @type {?} */\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  /** @type {?} */\n\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    /** @type {?} */\n    var html = element.ownerDocument.documentElement;\n    /** @type {?} */\n\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} offsets\n * @return {?}\n */\n\n\nfunction getClientRect(offsets) {\n  return Object.assign(Object.assign({}, offsets), {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getBoundingClientRect(element) {\n  /** @type {?} */\n  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      /** @type {?} */\n\n      var scrollTop = getScroll(element, 'top');\n      /** @type {?} */\n\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {\n    return undefined;\n  }\n  /** @type {?} */\n\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  }; // subtract scrollbar size from sizes\n\n  /** @type {?} */\n\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  /** @type {?} */\n\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  /** @type {?} */\n\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n  /** @type {?} */\n\n  var horizScrollbar = element.offsetWidth - width;\n  /** @type {?} */\n\n  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n\n  if (horizScrollbar || vertScrollbar) {\n    /** @type {?} */\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} rect\n * @param {?} element\n * @param {?=} subtract\n * @return {?}\n */\n\n\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  /** @type {?} */\n  var scrollTop = getScroll(element, 'top');\n  /** @type {?} */\n\n  var scrollLeft = getScroll(element, 'left');\n  /** @type {?} */\n\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} children\n * @param {?} parent\n * @param {?=} fixedPosition\n * @return {?}\n */\n\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  /** @type {?} */\n  var isIE10 = isIE(10);\n  /** @type {?} */\n\n  var isHTML = parent.nodeName === 'HTML';\n  /** @type {?} */\n\n  var childrenRect = getBoundingClientRect(children);\n  /** @type {?} */\n\n  var parentRect = getBoundingClientRect(parent);\n  /** @type {?} */\n\n  var scrollParent = getScrollParent(children);\n  /** @type {?} */\n\n  var styles = getStyleComputedProperty(parent);\n  /** @type {?} */\n\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  /** @type {?} */\n\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  /** @type {?} */\n\n\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n\n  if (!isIE10 && isHTML) {\n    /** @type {?} */\n    var marginTop = parseFloat(styles.marginTop);\n    /** @type {?} */\n\n    var marginLeft = parseFloat(styles.marginLeft);\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them\n\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @param {?=} excludeScroll\n * @return {?}\n */\n\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  /** @type {?} */\n  var html = element.ownerDocument.documentElement;\n  /** @type {?} */\n\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  /** @type {?} */\n\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  /** @type {?} */\n\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n  /** @type {?} */\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  /** @type {?} */\n\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  /** @type {?} */\n\n  var offset = {\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n    width: width,\n    height: height\n  };\n  return getClientRect(offset);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction isFixed(element) {\n  /** @type {?} */\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  /** @type {?} */\n\n\n  var el = element.parentElement;\n\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} padding\n * @param {?=} boundariesElement\n * @param {?=} fixedPosition\n * @return {?}\n */\n\n\nfunction getBoundaries(target, host) {\n  var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var boundariesElement = arguments.length > 3 ? arguments[3] : undefined;\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  // NOTE: 1 DOM access here\n  // NOTE: 1 DOM access here\n\n  /** @type {?} */\n  var boundaries = {\n    top: 0,\n    left: 0\n  };\n  /** @type {?} */\n\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host); // Handle viewport case\n\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n\n    /** @type {?} */\n    var boundariesNode;\n\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n    /** @type {?} */\n\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation\n\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(target.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = Number(height) + Number(offsets.top);\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = Number(width) + Number(offsets.left);\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  } // Add paddings\n\n\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n  return boundaries;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} __0\n * @return {?}\n */\n\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n  return width * height;\n}\n/**\n * @param {?} placement\n * @param {?} refRect\n * @param {?} target\n * @param {?} host\n * @param {?=} allowedPositions\n * @param {?=} boundariesElement\n * @param {?=} padding\n * @return {?}\n */\n\n\nfunction computeAutoPlacement(placement, refRect, target, host) {\n  var allowedPositions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ['top', 'bottom', 'right', 'left'];\n  var boundariesElement = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'viewport';\n  var padding = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n  /** @type {?} */\n\n\n  var boundaries = getBoundaries(target, host, padding, boundariesElement);\n  /** @type {?} */\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n  /** @type {?} */\n\n  var sortedAreas = Object.keys(rects).map(\n  /**\n  * @param {?} key\n  * @return {?}\n  */\n  function (key) {\n    return Object.assign(Object.assign({\n      key: key\n    }, rects[key]), {\n      area: getArea(rects[key])\n    });\n  }).sort(\n  /**\n  * @param {?} a\n  * @param {?} b\n  * @return {?}\n  */\n  function (a, b) {\n    return b.area - a.area;\n  });\n  /** @type {?} */\n\n  var filteredAreas = sortedAreas.filter(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= target.clientWidth && height >= target.clientHeight;\n  });\n  filteredAreas = filteredAreas.filter(\n  /**\n  * @param {?} position\n  * @return {?}\n  */\n  function (position) {\n    return allowedPositions.some(\n    /**\n    * @param {?} allowedPosition\n    * @return {?}\n    */\n    function (allowedPosition) {\n      return allowedPosition === position.key;\n    });\n  });\n  /** @type {?} */\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n  /** @type {?} */\n\n  var variation = placement.split(' ')[1]; // for tooltip on auto position\n\n  target.className = target.className.replace(/bs-tooltip-auto/g, \"bs-tooltip-\".concat(computedPlacement));\n  return computedPlacement + (variation ? \"-\".concat(variation) : '');\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction getOffsets(data) {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left),\n    top: Math.round(data.offsets.target.top),\n    bottom: Math.round(data.offsets.target.bottom),\n    right: Math.floor(data.offsets.target.right)\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Get the opposite placement of the given one\n * @param {?} placement\n * @return {?}\n */\n\n\nfunction getOppositePlacement(placement) {\n  /** @type {?} */\n  var hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g,\n  /**\n  * @param {?} matched\n  * @return {?}\n  */\n  function (matched) {\n    return (\n      /** @type {?} */\n      hash[matched]\n    );\n  });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Get the opposite placement variation of the given one\n * @param {?} variation\n * @return {?}\n */\n\n\nfunction getOppositeVariation(variation) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @param {?} element\n * @return {?}\n */\n\n\nfunction getOuterSizes(element) {\n  /** @type {?} */\n  var window = element.ownerDocument.defaultView;\n  /** @type {?} */\n\n  var styles = window.getComputedStyle(element);\n  /** @type {?} */\n\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  /** @type {?} */\n\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} target\n * @param {?} host\n * @param {?=} fixedPosition\n * @return {?}\n */\n\n\nfunction getReferenceOffsets(target, host) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  /** @type {?} */\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} target\n * @param {?} hostOffsets\n * @param {?} position\n * @return {?}\n */\n\n\nfunction getTargetOffsets(target, hostOffsets, position) {\n  /** @type {?} */\n  var placement = position.split(' ')[0]; // Get target node sizes\n\n  /** @type {?} */\n\n  var targetRect = getOuterSizes(target); // Add position, width and height to our offsets object\n\n  /** @type {?} */\n\n  var targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  }; // depending by the target placement we have to compute its offsets slightly differently\n\n  /** @type {?} */\n\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  /** @type {?} */\n\n  var mainSide = isHoriz ? 'top' : 'left';\n  /** @type {?} */\n\n  var secondarySide = isHoriz ? 'left' : 'top';\n  /** @type {?} */\n\n  var measurement = isHoriz ? 'height' : 'width';\n  /** @type {?} */\n\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  /** @type {?} */\n  targetOffsets[mainSide] = hostOffsets[mainSide] + hostOffsets[measurement] / 2 - targetRect[measurement] / 2;\n\n  /** @type {?} */\n  targetOffsets[secondarySide] = placement === secondarySide ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement] :\n  /** @type {?} */\n  hostOffsets[getOppositePlacement(secondarySide)];\n  return targetOffsets;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @param {?} options\n * @param {?} modifierName\n * @return {?}\n */\n\n\nfunction isModifierEnabled(options, modifierName) {\n  return options && options.modifiers && options.modifiers[modifierName] && options.modifiers[modifierName].enabled;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Tells if a given input is a number\n * @param {?} n\n * @return {?}\n */\n\n\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @param {?=} renderer\n * @return {?}\n */\n\n\nfunction updateContainerClass(data, renderer) {\n  /** @type {?} */\n  var target = data.instance.target;\n  /** @type {?} */\n\n  var containerClass = target.className;\n\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, \"bs-popover-\".concat(data.placement));\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, \"bs-tooltip-\".concat(data.placement));\n    containerClass = containerClass.replace(/\\sauto/g, \" \".concat(data.placement));\n\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n\n    if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n\n  containerClass = containerClass.replace(/left|right|top|bottom/g, \"\".concat(data.placement.split(' ')[0]));\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n    return;\n  }\n\n  target.className = containerClass;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} element\n * @param {?} styles\n * @param {?=} renderer\n * @return {?}\n */\n\n\nfunction setStyles(element, styles, renderer) {\n  Object.keys(styles).forEach(\n  /**\n  * @param {?} prop\n  * @return {?}\n  */\n  function (prop) {\n    /** @type {?} */\n    var unit = ''; // add unit if the value is numeric and is one of the following\n\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, \"\".concat(String(styles[prop])).concat(unit));\n      return;\n    }\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction arrow(data) {\n  var _data$offsets$arrow;\n\n  /** @type {?} */\n  var targetOffsets = data.offsets.target; // if arrowElement is a string, suppose it's a CSS selector\n\n  /** @type {?} */\n\n  var arrowElement = data.instance.target.querySelector('.arrow'); // if arrowElement is not found, don't run the modifier\n\n  if (!arrowElement) {\n    return data;\n  }\n  /** @type {?} */\n\n\n  var isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n  /** @type {?} */\n\n  var len = isVertical ? 'height' : 'width';\n  /** @type {?} */\n\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  /** @type {?} */\n\n  var side = sideCapitalized.toLowerCase();\n  /** @type {?} */\n\n  var altSide = isVertical ? 'left' : 'top';\n  /** @type {?} */\n\n  var opSide = isVertical ? 'bottom' : 'right';\n  /** @type {?} */\n\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n  /** @type {?} */\n\n  var placementVariation = data.placement.split(' ')[1]; // top/left side\n\n  if (data.offsets.host[opSide] - arrowElementSize <\n  /** @type {?} */\n  targetOffsets[side]) {\n    /** @type {?} */\n    targetOffsets[side] -=\n    /** @type {?} */\n    targetOffsets[side] - (data.offsets.host[opSide] - arrowElementSize);\n  } // bottom/right side\n\n\n  if (Number(\n  /** @type {?} */\n  data.offsets.host[side]) + Number(arrowElementSize) >\n  /** @type {?} */\n  targetOffsets[opSide]) {\n    /** @type {?} */\n    targetOffsets[side] += Number(\n    /** @type {?} */\n    data.offsets.host[side]) + Number(arrowElementSize) - Number(\n    /** @type {?} */\n    targetOffsets[opSide]);\n  }\n\n  targetOffsets = getClientRect(targetOffsets); // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n\n  /** @type {?} */\n\n  var css = getStyleComputedProperty(data.instance.target);\n  /** @type {?} */\n\n  var targetMarginSide = parseFloat(css[\"margin\".concat(sideCapitalized)]);\n  /** @type {?} */\n\n  var targetBorderSide = parseFloat(css[\"border\".concat(sideCapitalized, \"Width\")]); // compute center of the target\n\n  /** @type {?} */\n\n  var center;\n\n  if (!placementVariation) {\n    center = Number(\n    /** @type {?} */\n    data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n  } else {\n    /** @type {?} */\n    var targetBorderRadius = parseFloat(css.borderRadius);\n    /** @type {?} */\n\n    var targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n    center = side === placementVariation ? Number(\n    /** @type {?} */\n    data.offsets.host[side]) + targetSideArrowOffset : Number(\n    /** @type {?} */\n    data.offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n  }\n  /** @type {?} */\n\n\n  var sideValue = center -\n  /** @type {?} */\n  targetOffsets[side] - targetMarginSide - targetBorderSide; // prevent arrowElement from being placed not contiguously to its target\n\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n  data.offsets.arrow = (_data$offsets$arrow = {}, _defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), _defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n  data.instance.arrow = arrowElement;\n  return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction flip(data) {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  if (!isModifierEnabled(data.options, 'flip')) {\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    return data;\n  }\n  /** @type {?} */\n\n\n  var boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  'viewport', false // positionFixed\n  );\n  /** @type {?} */\n\n  var placement = data.placement.split(' ')[0];\n  /** @type {?} */\n\n  var variation = data.placement.split(' ')[1] || '';\n  /** @type {?} */\n\n  var offsetsHost = data.offsets.host;\n  /** @type {?} */\n\n  var target = data.instance.target;\n  /** @type {?} */\n\n  var host = data.instance.host;\n  /** @type {?} */\n\n  var adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  /** @type {?} */\n\n  var flipOrder = [placement, adaptivePosition];\n  /* tslint:disable-next-line: cyclomatic-complexity */\n\n  flipOrder.forEach(\n  /**\n  * @param {?} step\n  * @param {?} index\n  * @return {?}\n  */\n  function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split(' ')[0]; // using floor because the host offsets may contain decimals we are not going to consider here\n\n    /** @type {?} */\n\n    var overlapsRef = placement === 'left' && Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left) || placement === 'right' && Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right) || placement === 'top' && Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top) || placement === 'bottom' && Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom);\n    /** @type {?} */\n\n    var overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n    /** @type {?} */\n\n    var overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n    /** @type {?} */\n\n    var overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n    /** @type {?} */\n\n    var overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n    /** @type {?} */\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required\n\n    /** @type {?} */\n\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    /** @type {?} */\n\n    var flippedVariation = isVertical && variation === 'left' && overflowsLeft || isVertical && variation === 'right' && overflowsRight || !isVertical && variation === 'left' && overflowsTop || !isVertical && variation === 'right' && overflowsBottom;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? \" \".concat(variation) : '');\n      data.offsets.target = Object.assign(Object.assign({}, data.offsets.target), getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    }\n  });\n  return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} targetElement\n * @param {?} hostElement\n * @param {?} position\n * @param {?} options\n * @return {?}\n */\n\n\nfunction initData(targetElement, hostElement, position, options) {\n  /** @type {?} */\n  var hostElPosition = getReferenceOffsets(targetElement, hostElement);\n\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/) && !position.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\\s*(start|end)*$/)) {\n    /* tslint:disable-next-line: no-parameter-reassignment */\n    position = 'auto';\n  }\n  /** @type {?} */\n\n\n  var placementAuto = !!position.match(/auto/g); // support old placements 'auto left|right|top|bottom'\n\n  /** @type {?} */\n\n  var placement = position.match(/auto\\s(left|right|top|bottom)/) ? position.split(' ')[1] || 'auto' : position; // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n\n  /** @type {?} */\n\n  var matches = placement.match(/^(left|right|top|bottom)* ?(?!\\1)(left|right|top|bottom)?/);\n\n  if (matches) {\n    placement = matches[1] + (matches[2] ? \" \".concat(matches[2]) : '');\n  } // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n\n\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n    placement = 'auto';\n  }\n  /** @type {?} */\n\n\n  var targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n  placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n  return {\n    options: options,\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: null\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: null\n    },\n    positionFixed: false,\n    placement: placement,\n    placementAuto: placementAuto\n  };\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction preventOverflow(data) {\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  } // NOTE: DOM access here\n  // resets the targetOffsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n\n  /** @type {?} */\n\n\n  var transformProp = 'transform';\n  /** @type {?} */\n\n  var targetStyles = data.instance.target.style; // assignment to help minification\n\n  var top = targetStyles.top,\n      left = targetStyles.left,\n      transform = targetStyles[transformProp];\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n  /** @type {?} */\n\n  var boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  'scrollParent', false // positionFixed\n  ); // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n  /** @type {?} */\n\n  var order = ['left', 'right', 'top', 'bottom'];\n  /** @type {?} */\n\n  var check = {\n    /**\n     * @param {?} placement\n     * @return {?}\n     */\n    primary: function primary(placement) {\n      /** @type {?} */\n      var value =\n      /** @type {?} */\n      data.offsets.target[placement];\n\n      if (\n      /** @type {?} */\n      data.offsets.target[placement] < boundaries[placement] && !false // options.escapeWithReference\n      ) {\n        value = Math.max(\n        /** @type {?} */\n        data.offsets.target[placement], boundaries[placement]);\n      }\n\n      return _defineProperty({}, placement, value);\n    },\n\n    /**\n     * @param {?} placement\n     * @return {?}\n     */\n    secondary: function secondary(placement) {\n      /** @type {?} */\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      /** @type {?} */\n\n      var value = data.offsets.target[mainSide];\n\n      if (\n      /** @type {?} */\n      data.offsets.target[placement] > boundaries[placement] && !false // escapeWithReference\n      ) {\n        value = Math.min(data.offsets.target[mainSide], boundaries[placement] - (placement === 'right' ? data.offsets.target.width : data.offsets.target.height));\n      }\n\n      return _defineProperty({}, mainSide, value);\n    }\n  };\n  /** @type {?} */\n\n  var side;\n  order.forEach(\n  /**\n  * @param {?} placement\n  * @return {?}\n  */\n  function (placement) {\n    side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    data.offsets.target = Object.assign(Object.assign({}, data.offsets.target),\n    /** @type {?} */\n    check[side](placement));\n  });\n  return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} data\n * @return {?}\n */\n\n\nfunction shift(data) {\n  /** @type {?} */\n  var placement = data.placement;\n  /** @type {?} */\n\n  var basePlacement = placement.split(' ')[0];\n  /** @type {?} */\n\n  var shiftVariation = placement.split(' ')[1];\n\n  if (shiftVariation) {\n    var _data$offsets = data.offsets,\n        host = _data$offsets.host,\n        target = _data$offsets.target;\n    /** @type {?} */\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    /** @type {?} */\n\n    var side = isVertical ? 'left' : 'top';\n    /** @type {?} */\n\n    var measurement = isVertical ? 'width' : 'height';\n    /** @type {?} */\n\n    var shiftOffsets = {\n      start: _defineProperty({}, side, host[side]),\n      end: _defineProperty({}, side, host[side] + host[measurement] - target[measurement])\n    };\n    data.offsets.target = Object.assign(Object.assign({}, target), _defineProperty({}, side, side === shiftVariation ?\n    /** @type {?} */\n    shiftOffsets.start[side] :\n    /** @type {?} */\n    shiftOffsets.end[side]));\n  }\n\n  return data;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar Positioning = /*#__PURE__*/function () {\n  function Positioning() {\n    _classCallCheck(this, Positioning);\n  }\n\n  _createClass(Positioning, [{\n    key: \"position\",\n    value:\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?=} round\n     * @return {?}\n     */\n    function position(hostElement, targetElement) {\n      var round = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return this.offset(hostElement, targetElement, false);\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?=} round\n     * @return {?}\n     */\n\n  }, {\n    key: \"offset\",\n    value: function offset(hostElement, targetElement) {\n      var round = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return getReferenceOffsets(targetElement, hostElement);\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} targetElement\n     * @param {?} position\n     * @param {?=} appendToBody\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"positionElements\",\n    value: function positionElements(hostElement, targetElement, position, appendToBody, options) {\n      /** @type {?} */\n      var chainOfModifiers = [flip, shift, preventOverflow, arrow];\n      return chainOfModifiers.reduce(\n      /**\n      * @param {?} modifiedData\n      * @param {?} modifier\n      * @return {?}\n      */\n      function (modifiedData, modifier) {\n        return modifier(modifiedData);\n      }, initData(targetElement, hostElement, position, options));\n    }\n  }]);\n\n  return Positioning;\n}();\n/** @type {?} */\n\n\nvar positionService = new Positioning();\n/**\n * @param {?} hostElement\n * @param {?} targetElement\n * @param {?} placement\n * @param {?=} appendToBody\n * @param {?=} options\n * @param {?=} renderer\n * @return {?}\n */\n\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n  /** @type {?} */\n  var data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n  /** @type {?} */\n\n  var offsets = getOffsets(data);\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: \"translate3d(\".concat(offsets.left, \"px, \").concat(offsets.top, \"px, 0px)\")\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  updateContainerClass(data, renderer);\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction PositioningOptions() {}\n\nif (false) {\n  /**\n   * The DOM element, ElementRef, or a selector string of an element which will be moved\n   * @type {?|undefined}\n   */\n  PositioningOptions.prototype.element;\n  /**\n   * The DOM element, ElementRef, or a selector string of an element which the element will be attached to\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.target;\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.attachment;\n  /**\n   * A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.targetAttachment;\n  /**\n   * A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.offset;\n  /**\n   * A string similar to `offset`, but referring to the offset of the target\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.targetOffset;\n  /**\n   * If true component will be attached to body\n   * @type {?|undefined}\n   */\n\n  PositioningOptions.prototype.appendToBody;\n}\n\nvar PositioningService = /*#__PURE__*/function () {\n  /**\n   * @param {?} ngZone\n   * @param {?} rendererFactory\n   * @param {?} platformId\n   */\n  function PositioningService(ngZone, rendererFactory, platformId) {\n    var _this = this;\n\n    _classCallCheck(this, PositioningService);\n\n    this.update$$ = new Subject();\n    this.positionElements = new Map();\n    this.isDisabled = false;\n\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        _this.triggerEvent$ = merge(fromEvent(window, 'scroll', {\n          passive: true\n        }), fromEvent(window, 'resize', {\n          passive: true\n        }),\n        /* tslint:disable-next-line: deprecation */\n        of(0, animationFrameScheduler), _this.update$$);\n\n        _this.triggerEvent$.subscribe(\n        /**\n        * @return {?}\n        */\n        function () {\n          if (_this.isDisabled) {\n            return;\n          }\n\n          _this.positionElements\n          /* tslint:disable-next-line: no-any */\n          .forEach(\n          /**\n          * @param {?} positionElement\n          * @return {?}\n          */\n          function (positionElement) {\n            positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, _this.options, rendererFactory.createRenderer(null, null));\n          });\n        });\n      });\n    }\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  _createClass(PositioningService, [{\n    key: \"position\",\n    value: function position(options) {\n      this.addPositionElement(options);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"event$\",\n    get: function get() {\n      return this.triggerEvent$;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.isDisabled = true;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.isDisabled = false;\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"addPositionElement\",\n    value: function addPositionElement(options) {\n      this.positionElements.set(_getHtmlElement(options.element), options);\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"calcPosition\",\n    value: function calcPosition() {\n      this.update$$.next();\n    }\n    /**\n     * @param {?} elRef\n     * @return {?}\n     */\n\n  }, {\n    key: \"deletePositionElement\",\n    value: function deletePositionElement(elRef) {\n      this.positionElements.delete(_getHtmlElement(elRef));\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n  }]);\n\n  return PositioningService;\n}();\n\nPositioningService.Éµfac = function PositioningService_Factory(t) {\n  return new (t || PositioningService)(Éµngcc0.ÉµÉµinject(Éµngcc0.NgZone), Éµngcc0.ÉµÉµinject(Éµngcc0.RendererFactory2), Éµngcc0.ÉµÉµinject(PLATFORM_ID));\n};\n\nPositioningService.Éµprov = Éµngcc0.ÉµÉµdefineInjectable({\n  token: PositioningService,\n  factory: PositioningService.Éµfac\n});\n/** @nocollapse */\n\nPositioningService.ctorParameters = function () {\n  return [{\n    type: NgZone\n  }, {\n    type: RendererFactory2\n  }, {\n    type: Number,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }];\n};\n/*@__PURE__*/\n\n\n(function () {\n  Éµngcc0.ÉµsetClassMetadata(PositioningService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Éµngcc0.NgZone\n    }, {\n      type: Éµngcc0.RendererFactory2\n    }, {\n      type: Number,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  PositioningService.prototype.options;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PositioningService.prototype.update$$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PositioningService.prototype.positionElements;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PositioningService.prototype.triggerEvent$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  PositioningService.prototype.isDisabled;\n}\n/**\n * @param {?} element\n * @return {?}\n */\n\n\nfunction _getHtmlElement(element) {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { Positioning, PositioningService, positionElements };","map":{"version":3,"sources":["ngx-bootstrap/positioning/utils/getStyleComputedProperty.ts","ngx-bootstrap/positioning/utils/getParentNode.ts","ngx-bootstrap/positioning/utils/getScrollParent.ts","ngx-bootstrap/positioning/utils/isBrowser.ts","ngx-bootstrap/positioning/utils/isIE.ts","ngx-bootstrap/positioning/utils/getOffsetParent.ts","ngx-bootstrap/positioning/utils/isOffsetContainer.ts","ngx-bootstrap/positioning/utils/getRoot.ts","ngx-bootstrap/positioning/utils/findCommonOffsetParent.ts","ngx-bootstrap/positioning/utils/getBordersSize.ts","ngx-bootstrap/positioning/utils/getWindowSizes.ts","ngx-bootstrap/positioning/utils/getScroll.ts","ngx-bootstrap/positioning/utils/getClientRect.ts","ngx-bootstrap/positioning/utils/getBoundingClientRect.ts","ngx-bootstrap/positioning/utils/includeScroll.ts","ngx-bootstrap/positioning/utils/getOffsetRectRelativeToArbitraryNode.ts","ngx-bootstrap/positioning/utils/getViewportOffsetRectRelativeToArtbitraryNode.ts","ngx-bootstrap/positioning/utils/isFixed.ts","ngx-bootstrap/positioning/utils/getFixedPositionOffsetParent.ts","ngx-bootstrap/positioning/utils/getBoundaries.ts","ngx-bootstrap/positioning/utils/computeAutoPlacement.ts","ngx-bootstrap/positioning/utils/getOffsets.ts","ngx-bootstrap/positioning/utils/getOppositePlacement.ts","ngx-bootstrap/positioning/utils/getOppositeVariation.ts","ngx-bootstrap/positioning/utils/getOuterSizes.ts","ngx-bootstrap/positioning/utils/getReferenceOffsets.ts","ngx-bootstrap/positioning/utils/getTargetOffsets.ts","ngx-bootstrap/positioning/utils/isModifierEnabled.ts","ngx-bootstrap/positioning/utils/isNumeric.ts","ngx-bootstrap/positioning/utils/updateContainerClass.ts","ngx-bootstrap/positioning/utils/setStyles.ts","ngx-bootstrap/positioning/modifiers/arrow.ts","ngx-bootstrap/positioning/modifiers/flip.ts","ngx-bootstrap/positioning/modifiers/initData.ts","ngx-bootstrap/positioning/modifiers/preventOverflow.ts","ngx-bootstrap/positioning/modifiers/shift.ts","ngx-bootstrap/positioning/ng-positioning.ts","ngx-bootstrap/positioning/positioning.service.ts"],"names":["runIsIE"],"mappings":"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","sourcesContent":["/**\n * Get CSS computed property of the given element\n */\nexport function getStyleComputedProperty(element: HTMLElement, property?: string): any {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  const window = element.ownerDocument.defaultView;\n  const css = window.getComputedStyle(element, null);\n\n  return property ? css[property as any] : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n */\nexport function getParentNode(element: any): any {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n","/**\n * Returns the scrolling parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function getScrollParent(element: any): any {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n    default:\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n","export const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n","/**\n * Determines if the browser is Internet Explorer\n */\nimport { isBrowser } from './isBrowser';\n\nconst isIE11 = isBrowser && !!((window as any).MSInputMethodContext && (document as any).documentMode);\nconst isIE10 = isBrowser && !!((window as any).MSInputMethodContext && /MSIE 10/.test((navigator as any).userAgent));\n\nexport function isIE(version?: number) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n","/**\n * Returns the offset parent of the given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getOffsetParent(element: any): any {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  const noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  let offsetParent = element.offsetParent || null;\n\n  // Skip hidden elements which don't have an offsetParent\n  let sibling: HTMLElement | null;\n\n  while (offsetParent === noOffsetParent\n         && element.nextElementSibling\n         && sibling !== element.nextElementSibling) {\n\n      sibling = element.nextElementSibling;\n      offsetParent = sibling.offsetParent;\n    }\n\n  const nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  if (\n    ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n    getStyleComputedProperty(offsetParent, 'position') === 'static'\n  ) {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n","import { getOffsetParent } from './getOffsetParent';\n\nexport function isOffsetContainer(element: any) {\n  const { nodeName } = element;\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return (\n    nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element\n  );\n}\n","/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nexport function getRoot(node: Node): any {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n","/**\n * Finds the offset parent common to the two provided nodes\n */\nimport { isOffsetContainer } from './isOffsetContainer';\nimport { getRoot } from './getRoot';\nimport { getOffsetParent } from './getOffsetParent';\n\nexport function findCommonOffsetParent(element1: HTMLElement, element2: HTMLElement): any {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  /* tslint:disable-next-line: no-bitwise */\n  const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n\n  const start = order ? element1 : element2;\n  const end = order ? element2 : element1;\n\n  // Get common ancestor container\n  const range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  const { commonAncestorContainer } = range;\n\n  // Both nodes are inside #document\n  if (\n    (element1 !== commonAncestorContainer &&\n      element2 !== commonAncestorContainer) ||\n    start.contains(end)\n  ) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  const element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n","/**\n * Helper to detect borders of a given element\n */\n\nexport function getBordersSize(styles: CSSStyleDeclaration, axis: string) {\n  const sideA = axis === 'x' ? 'Left' : 'Top';\n  const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return (\n    parseFloat(styles[`border${sideA}Width` as any]) +\n    parseFloat(styles[`border${sideB}Width` as any])\n  );\n}\n","import { isIE } from './isIE';\n\nfunction getSize(axis: string, body: HTMLElement, html: HTMLElement, computedStyle: CSSStyleDeclaration) {\n  return Math.max(\n    (body as any)[`offset${axis}`],\n    (body as any)[`scroll${axis}`],\n    (html as any)[`client${axis}`],\n    (html as any)[`offset${axis}`],\n    (html as any)[`scroll${axis}`],\n    isIE(10)\n      ? (parseInt((html as any)[`offset${axis}`], 10) +\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Top' : 'Left'}` as any], 10) +\n      parseInt(computedStyle[`margin${axis === 'Height' ? 'Bottom' : 'Right'}` as any], 10))\n    : 0\n  );\n}\n\nexport function getWindowSizes(document: Document) {\n  const body = document.body;\n  const html = document.documentElement;\n  const computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n","/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nexport function getScroll(element: HTMLElement, side = 'top') {\n  const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  const nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    const html = element.ownerDocument.documentElement;\n    const scrollingElement = element.ownerDocument.scrollingElement || html;\n\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n","/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n */\nimport { Offsets } from '../models';\n\nexport function getClientRect(offsets: Offsets): Offsets {\n  return {\n    ...offsets,\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  };\n}\n","/**\n * Get bounding client rect of given element\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getBordersSize } from './getBordersSize';\nimport { getWindowSizes } from './getWindowSizes';\nimport { getScroll } from './getScroll';\nimport { getClientRect } from './getClientRect';\nimport { isIE } from './isIE';\nimport { Offsets } from '../models';\n\nexport function getBoundingClientRect(element: HTMLElement): Offsets {\n  let rect: any = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      const scrollTop = getScroll(element, 'top');\n      const scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {\n    return undefined;\n  }\n\n  const result: any = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  const sizes: any = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  const width =\n    sizes.width || element.clientWidth || result.right - result.left;\n  const height =\n    sizes.height || element.clientHeight || result.bottom - result.top;\n\n  let horizScrollbar = element.offsetWidth - width;\n  let vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    const styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n","/**\n * Sum or subtract the element scroll values (left and top) from a given rect object\n */\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function includeScroll(rect: Offsets, element: HTMLElement, subtract = false) {\n  const scrollTop = getScroll(element, 'top');\n  const scrollLeft = getScroll(element, 'left');\n  const modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n\n  return rect;\n}\n","import { getBoundingClientRect } from './getBoundingClientRect';\nimport { getClientRect } from './getClientRect';\nimport { getScrollParent } from './getScrollParent';\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { includeScroll } from './includeScroll';\nimport { isIE as runIsIE } from './isIE';\nimport { Offsets } from '../models';\n\nexport function getOffsetRectRelativeToArbitraryNode(\n  children: HTMLElement,\n  parent: HTMLElement,\n  fixedPosition = false\n): Offsets {\n  const isIE10 = runIsIE(10);\n  const isHTML = parent.nodeName === 'HTML';\n  const childrenRect: any = getBoundingClientRect(children);\n  const parentRect: any = getBoundingClientRect(parent);\n  const scrollParent = getScrollParent(children);\n\n  const styles = getStyleComputedProperty(parent);\n  const borderTopWidth = parseFloat(styles.borderTopWidth);\n  const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n\n  let offsets: Offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    const marginTop = parseFloat(styles.marginTop);\n    const marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (\n    isIE10 && !fixedPosition\n      ? parent.contains(scrollParent)\n      : parent === scrollParent && scrollParent.nodeName !== 'BODY'\n  ) {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n","import { getClientRect } from './getClientRect';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getScroll } from './getScroll';\nimport { Offsets } from '../models';\n\nexport function getViewportOffsetRectRelativeToArtbitraryNode(element: HTMLElement, excludeScroll = false): Offsets {\n  const html = element.ownerDocument.documentElement;\n  const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  const width = Math.max(html.clientWidth, window.innerWidth || 0);\n  const height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  const scrollTop = !excludeScroll ? getScroll(html) : 0;\n  const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  const offset = {\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n    width,\n    height\n  };\n\n  return getClientRect(offset);\n}\n","/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { getParentNode } from './getParentNode';\n\nexport function isFixed(element: HTMLElement): boolean {\n  const nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n","/**\n * Finds the first parent of an element that has a transformed property defined\n */\n\nimport { getStyleComputedProperty } from './getStyleComputedProperty';\nimport { isIE } from './isIE';\n\nexport function getFixedPositionOffsetParent(element: HTMLElement): HTMLElement {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n   return document.documentElement;\n  }\n\n  let el = element.parentElement;\n\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n","/**\n * Computed the boundaries limits and return them\n */\nimport { getScrollParent } from './getScrollParent';\nimport { getParentNode } from './getParentNode';\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getViewportOffsetRectRelativeToArtbitraryNode } from './getViewportOffsetRectRelativeToArtbitraryNode';\nimport { getWindowSizes } from './getWindowSizes';\nimport { isFixed } from './isFixed';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\n\nexport function getBoundaries(\n  target: HTMLElement,\n  host: HTMLElement,\n  padding = 0,\n  boundariesElement: string,\n  fixedPosition = false\n) {\n  // NOTE: 1 DOM access here\n\n  let boundaries: any = { top: 0, left: 0 };\n  const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    let boundariesNode;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    const offsets = getOffsetRectRelativeToArbitraryNode(\n      boundariesNode,\n      offsetParent,\n      fixedPosition\n    );\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      const { height, width } = getWindowSizes(target.ownerDocument);\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = Number(height) + Number(offsets.top);\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = Number(width) + Number(offsets.left);\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n\n  return boundaries;\n}\n","/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nimport { getBoundaries } from './getBoundaries';\nimport { Offsets } from '../models';\n\nfunction getArea({ width, height }: { [key: string]: number }) {\n  return width * height;\n}\n\nexport function computeAutoPlacement(\n  placement: string,\n  refRect: Offsets,\n  target: HTMLElement,\n  host: HTMLElement,\n  allowedPositions: any[] = ['top', 'bottom', 'right', 'left'],\n  boundariesElement = 'viewport',\n  padding = 0\n) {\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  const boundaries = getBoundaries(target, host, padding, boundariesElement);\n\n  const rects: any = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  const sortedAreas = Object.keys(rects)\n    .map(key => ({\n      key,\n      ...rects[key],\n      area: getArea(rects[key])\n    }))\n    .sort((a, b) => b.area - a.area);\n\n  let filteredAreas: any[] = sortedAreas.filter(\n    ({ width, height }) => {\n      return width >= target.clientWidth\n        && height >= target.clientHeight;\n    }\n  );\n\n  filteredAreas = filteredAreas.filter((position: any) => {\n    return allowedPositions\n      .some((allowedPosition: string) => {\n        return allowedPosition === position.key;\n      });\n  });\n\n  const computedPlacement: string = filteredAreas.length > 0\n    ? filteredAreas[0].key\n    : sortedAreas[0].key;\n\n  const variation = placement.split(' ')[1];\n\n  // for tooltip on auto position\n  target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${computedPlacement}`);\n\n  return computedPlacement + (variation ? `-${variation}` : '');\n}\n","import { Data, Offsets } from '../models';\n\nexport function getOffsets(data: Data): Offsets {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left),\n    top: Math.round(data.offsets.target.top),\n    bottom: Math.round(data.offsets.target.bottom),\n    right: Math.floor(data.offsets.target.right)\n  };\n}\n","/**\n * Get the opposite placement of the given one\n */\nexport function getOppositePlacement(placement: string) {\n  const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n\n  return placement.replace(/left|right|bottom|top/g, matched => (hash as any)[matched]);\n}\n","/**\n * Get the opposite placement variation of the given one\n */\nexport function getOppositeVariation(variation: string) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n */\nexport function getOuterSizes(element: any) {\n  const window = element.ownerDocument.defaultView;\n  const styles = window.getComputedStyle(element);\n  const x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  const y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n","/**\n * Get offsets to the reference element\n */\nimport { findCommonOffsetParent } from './findCommonOffsetParent';\nimport { getOffsetRectRelativeToArbitraryNode } from './getOffsetRectRelativeToArbitraryNode';\nimport { getFixedPositionOffsetParent } from './getFixedPositionOffsetParent';\nimport { Offsets } from '../models';\n\nexport function getReferenceOffsets(\n  target: HTMLElement,\n  host: HTMLElement,\n  fixedPosition: boolean = null\n): Offsets {\n  const commonOffsetParent = fixedPosition\n    ? getFixedPositionOffsetParent(target)\n    : findCommonOffsetParent(target, host);\n\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n","/**\n * Get offsets to the target\n */\nimport { getOppositePlacement } from './getOppositePlacement';\nimport { getOuterSizes } from './getOuterSizes';\nimport { Offsets } from '../models';\n\nexport function getTargetOffsets(\n  target: HTMLElement,\n  hostOffsets: Offsets,\n  position: string\n): Offsets {\n  const placement = position.split(' ')[0];\n\n  // Get target node sizes\n  const targetRect = getOuterSizes(target);\n\n  // Add position, width and height to our offsets object\n  const targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  };\n\n  // depending by the target placement we have to compute its offsets slightly differently\n  const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  const mainSide = isHoriz ? 'top' : 'left';\n  const secondarySide = isHoriz ? 'left' : 'top';\n  const measurement = isHoriz ? 'height' : 'width';\n  const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  (targetOffsets as any)[mainSide] =\n    hostOffsets[mainSide] +\n    hostOffsets[measurement] / 2 -\n    targetRect[measurement] / 2;\n\n  (targetOffsets as any)[secondarySide] = placement === secondarySide\n    ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement]\n    : (hostOffsets as any)[getOppositePlacement(secondarySide)];\n\n  return targetOffsets;\n}\n","/**\n * Helper used to know if the given modifier is enabled.\n */\nexport function isModifierEnabled(options: any, modifierName: string) {\n  return options\n    && options.modifiers\n    && options.modifiers[modifierName]\n    && options.modifiers[modifierName].enabled;\n}\n","/**\n * Tells if a given input is a number\n */\nexport function isNumeric(n: any) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n","/**\n * Update class for the given popper\n */\nimport { Renderer2 } from '@angular/core';\nimport { Data } from '../models';\n\nexport function updateContainerClass(data: Data, renderer?: Renderer2): void {\n  const target = data.instance.target;\n\n  let containerClass = target.className;\n\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${data.placement}`);\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${data.placement}`);\n    containerClass = containerClass.replace(/\\sauto/g, ` ${data.placement}`);\n\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n\n    if (containerClass.indexOf('tooltip') !== -1  && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n\n  containerClass = containerClass.replace(/left|right|top|bottom/g, `${data.placement.split(' ')[0]}`);\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n\n    return;\n  }\n\n  target.className = containerClass;\n}\n","/**\n * Set the style to the given popper\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { isNumeric } from './isNumeric';\n\nexport function setStyles(element: HTMLElement, styles: any, renderer?: Renderer2) {\n  Object.keys(styles).forEach((prop: any) => {\n    let unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n      isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n\n      return;\n    }\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n","import { getClientRect, getOuterSizes, getStyleComputedProperty } from '../utils';\nimport { Data } from '../models';\n\nexport function arrow(data: Data) {\n  let targetOffsets = data.offsets.target;\n  // if arrowElement is a string, suppose it's a CSS selector\n  const arrowElement: HTMLElement | null = data.instance.target.querySelector('.arrow');\n\n  // if arrowElement is not found, don't run the modifier\n  if (!arrowElement) {\n    return data;\n  }\n\n  const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n\n  const len = isVertical ? 'height' : 'width';\n  const sideCapitalized = isVertical ? 'Top' : 'Left';\n  const side = sideCapitalized.toLowerCase();\n  const altSide = isVertical ? 'left' : 'top';\n  const opSide = isVertical ? 'bottom' : 'right';\n  const arrowElementSize = getOuterSizes(arrowElement)[len];\n  const placementVariation = data.placement.split(' ')[1];\n\n  // top/left side\n  if (data.offsets.host[opSide] - arrowElementSize < (targetOffsets as any)[side]) {\n    (targetOffsets as any)[side] -=\n      (targetOffsets as any)[side] - (data.offsets.host[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (Number((data as any).offsets.host[side]) + Number(arrowElementSize) > (targetOffsets as any)[opSide]) {\n    (targetOffsets as any)[side] +=\n      Number((data as any).offsets.host[side]) + Number(arrowElementSize) - Number((targetOffsets as any)[opSide]);\n  }\n  targetOffsets = getClientRect(targetOffsets);\n\n  // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n  const css = getStyleComputedProperty(data.instance.target);\n  const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]);\n  const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]);\n\n  // compute center of the target\n  let center: number;\n  if (!placementVariation) {\n    center = Number((data as any).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n  } else {\n    const targetBorderRadius = parseFloat(css.borderRadius);\n    const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n    center = side === placementVariation ?\n      Number((data as any).offsets.host[side]) + targetSideArrowOffset :\n      Number((data as any).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n  }\n\n  let sideValue =\n    center - (targetOffsets as any)[side] - targetMarginSide - targetBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its target\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n\n  data.offsets.arrow = {\n    [side]: Math.round(sideValue),\n    [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n  };\n\n  data.instance.arrow = arrowElement;\n\n  return data;\n}\n","import {\n  computeAutoPlacement,\n  getBoundaries,\n  getClientRect,\n  getOppositeVariation,\n  getTargetOffsets,\n  isModifierEnabled\n} from '../utils';\n\nimport { Data } from '../models';\n\nexport function flip(data: Data): Data {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  if (!isModifierEnabled(data.options, 'flip')) {\n\n    data.offsets.target = {\n      ...data.offsets.target,\n      ...getTargetOffsets(\n        data.instance.target,\n        data.offsets.host,\n        data.placement\n      )\n    };\n\n    return data;\n  }\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'viewport',\n    false // positionFixed\n  );\n\n  let placement = data.placement.split(' ')[0];\n  let variation = data.placement.split(' ')[1] || '';\n\n  const offsetsHost = data.offsets.host;\n  const target = data.instance.target;\n  const host = data.instance.host;\n\n  const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  const flipOrder = [placement, adaptivePosition];\n\n  /* tslint:disable-next-line: cyclomatic-complexity */\n  flipOrder.forEach((step, index) => {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split(' ')[0];\n\n    // using floor because the host offsets may contain decimals we are not going to consider here\n    const overlapsRef =\n      (placement === 'left' &&\n        Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left)) ||\n      (placement === 'right' &&\n        Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right)) ||\n      (placement === 'top' &&\n        Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top)) ||\n      (placement === 'bottom' &&\n        Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom));\n\n    const overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n    const overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n    const overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n    const overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n\n    const overflowsBoundaries =\n      (placement === 'left' && overflowsLeft) ||\n      (placement === 'right' && overflowsRight) ||\n      (placement === 'top' && overflowsTop) ||\n      (placement === 'bottom' && overflowsBottom);\n\n    // flip the variation if required\n    const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    const flippedVariation =\n      ((isVertical && variation === 'left' && overflowsLeft) ||\n        (isVertical && variation === 'right' && overflowsRight) ||\n        (!isVertical && variation === 'left' && overflowsTop) ||\n        (!isVertical && variation === 'right' && overflowsBottom));\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? ` ${variation}` : '');\n\n      data.offsets.target = {\n        ...data.offsets.target,\n        ...getTargetOffsets(\n          data.instance.target,\n          data.offsets.host,\n          data.placement\n        )\n      };\n    }\n  });\n\n  return data;\n}\n","import {\n  computeAutoPlacement,\n  getReferenceOffsets,\n  getTargetOffsets\n} from '../utils';\n\nimport { Data, Options } from '../models';\n\nexport function initData(\n  targetElement: HTMLElement, hostElement: HTMLElement, position: string, options: Options\n): Data {\n\n  const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/)\n    && !position.match(/^(left|right|top|bottom)*(?: (left|right|top|bottom))?\\s*(start|end)*$/)) {\n      /* tslint:disable-next-line: no-parameter-reassignment */\n      position = 'auto';\n    }\n\n  const placementAuto = !!position.match(/auto/g);\n\n  // support old placements 'auto left|right|top|bottom'\n  let placement = position.match(/auto\\s(left|right|top|bottom)/)\n    ? position.split(' ')[1] || 'auto'\n    : position;\n\n  // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n  const matches = placement.match(/^(left|right|top|bottom)* ?(?!\\1)(left|right|top|bottom)?/);\n  if (matches) {\n    placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n  }\n\n  // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n  if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n    placement = 'auto';\n  }\n\n  const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n\n  placement = computeAutoPlacement(\n    placement,\n    hostElPosition,\n    targetElement,\n    hostElement,\n    options ? options.allowedPositions : undefined\n  );\n\n  return {\n    options,\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: null\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: null\n    },\n    positionFixed: false,\n    placement,\n    placementAuto\n  };\n}\n","import { getBoundaries, isModifierEnabled } from '../utils';\nimport { Data } from '../models';\n\nexport function preventOverflow(data: Data) {\n\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  }\n\n  // NOTE: DOM access here\n  // resets the targetOffsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n  const transformProp = 'transform';\n  const targetStyles = data.instance.target.style; // assignment to help minification\n  const { top, left, [transformProp]: transform } = targetStyles;\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n\n  const boundaries = getBoundaries(\n    data.instance.target,\n    data.instance.host,\n    0, // padding\n    'scrollParent',\n    false // positionFixed\n  );\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n\n  const order = ['left', 'right', 'top', 'bottom'];\n\n  const check = {\n    primary(placement: string) {\n      let value = (data as any).offsets.target[placement];\n      if (\n        (data as any).offsets.target[placement] < boundaries[placement] &&\n        !false // options.escapeWithReference\n      ) {\n        value = Math.max((data as any).offsets.target[placement], boundaries[placement]);\n      }\n\n      return { [placement]: value };\n    },\n    secondary(placement: string) {\n      const mainSide = placement === 'right' ? 'left' : 'top';\n      let value = data.offsets.target[mainSide];\n      if (\n        (data as any).offsets.target[placement] > boundaries[placement] &&\n        !false // escapeWithReference\n      ) {\n        value = Math.min(\n          data.offsets.target[mainSide],\n          boundaries[placement] -\n          (placement === 'right' ? data.offsets.target.width : data.offsets.target.height)\n        );\n      }\n\n      return { [mainSide]: value };\n    }\n  };\n\n  let side: string;\n\n  order.forEach(placement => {\n    side = ['left', 'top']\n      .indexOf(placement) !== -1\n      ? 'primary'\n      : 'secondary';\n\n    data.offsets.target = {\n      ...data.offsets.target,\n      ...(check as any)[side](placement)\n    };\n\n  });\n\n  return data;\n}\n","import { Data } from '../models';\n\nexport function shift(data: Data): Data {\n  const placement = data.placement;\n  const basePlacement = placement.split(' ')[0];\n  const shiftVariation = placement.split(' ')[1];\n\n  if (shiftVariation) {\n    const { host, target } = data.offsets;\n    const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    const side = isVertical ? 'left' : 'top';\n    const measurement = isVertical ? 'width' : 'height';\n\n    const shiftOffsets = {\n      start: { [side]: host[side] },\n      end: {\n        [side]: host[side] + host[measurement] - target[measurement]\n      }\n    };\n\n    data.offsets.target = {\n      ...target, ...{\n        [side]: (side === shiftVariation ? (shiftOffsets as any).start[side] : (shiftOffsets as any).end[side])\n      }\n    };\n  }\n\n  return data;\n}\n","/**\n * @copyright Valor Software\n * @copyright Federico Zivolo and contributors\n */\nimport { Renderer2 } from '@angular/core';\n\nimport { getOffsets, getReferenceOffsets, updateContainerClass, setStyles } from './utils';\n\nimport { arrow, flip, preventOverflow, shift, initData } from './modifiers';\nimport { Data, Offsets, Options } from './models';\n\n\nexport class Positioning {\n  position(hostElement: HTMLElement, targetElement: HTMLElement, round = true): Offsets {\n    return this.offset(hostElement, targetElement, false);\n  }\n\n  offset(hostElement: HTMLElement, targetElement: HTMLElement, round = true): Offsets {\n    return getReferenceOffsets(targetElement, hostElement);\n  }\n\n  positionElements(\n    hostElement: HTMLElement,\n    targetElement: HTMLElement,\n    position: string,\n    appendToBody?: boolean,\n    options?: Options\n  ): Data {\n    const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n\n    return chainOfModifiers.reduce(\n      (modifiedData, modifier) => modifier(modifiedData),\n      initData(targetElement, hostElement, position, options)\n    );\n  }\n}\n\nconst positionService = new Positioning();\n\nexport function positionElements(\n  hostElement: HTMLElement,\n  targetElement: HTMLElement,\n  placement: string,\n  appendToBody?: boolean,\n  options?: Options,\n  renderer?: Renderer2\n): void {\n\n  const data = positionService.positionElements(\n    hostElement,\n    targetElement,\n    placement,\n    appendToBody,\n    options\n  );\n\n  const offsets = getOffsets(data);\n\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  updateContainerClass(data, renderer);\n}\n","import { Injectable, ElementRef, RendererFactory2, Inject, PLATFORM_ID, NgZone } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\n\nimport { positionElements } from './ng-positioning';\n\nimport { fromEvent, merge, of, animationFrameScheduler, Subject, Observable } from 'rxjs';\nimport { Options } from './models';\n\n\nexport interface PositioningOptions {\n  /** The DOM element, ElementRef, or a selector string of an element which will be moved */\n  element?: HTMLElement | ElementRef | string;\n\n  /** The DOM element, ElementRef, or a selector string of an element which the element will be attached to  */\n  target?: HTMLElement | ElementRef | string;\n\n  /**\n   * A string of the form 'vert-attachment horiz-attachment' or 'placement'\n   * - placement can be \"top\", \"bottom\", \"left\", \"right\"\n   * not yet supported:\n   * - vert-attachment can be any of 'top', 'middle', 'bottom'\n   * - horiz-attachment can be any of 'left', 'center', 'right'\n   */\n  attachment?: string;\n\n  /** A string similar to `attachment`. The one difference is that, if it's not provided,\n   * `targetAttachment` will assume the mirror image of `attachment`.\n   */\n  targetAttachment?: string;\n\n  /** A string of the form 'vert-offset horiz-offset'\n   * - vert-offset and horiz-offset can be of the form \"20px\" or \"55%\"\n   */\n  offset?: string;\n\n  /** A string similar to `offset`, but referring to the offset of the target */\n  targetOffset?: string;\n\n  /** If true component will be attached to body */\n  appendToBody?: boolean;\n}\n\n\n@Injectable()\nexport class PositioningService {\n  private options: Options;\n  private update$$ = new Subject<null>();\n  private positionElements = new Map();\n  private triggerEvent$: Observable<number|Event>;\n  private isDisabled = false;\n\n  constructor(\n    ngZone: NgZone,\n    rendererFactory: RendererFactory2,\n    @Inject(PLATFORM_ID) platformId: number\n  ) {\n\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(() => {\n        this.triggerEvent$ = merge(\n          fromEvent(window, 'scroll', { passive: true }),\n          fromEvent(window, 'resize', { passive: true }),\n          /* tslint:disable-next-line: deprecation */\n          of(0, animationFrameScheduler),\n          this.update$$\n        );\n\n        this.triggerEvent$.subscribe(() => {\n          if (this.isDisabled) {\n            return;\n          }\n\n          this.positionElements\n          /* tslint:disable-next-line: no-any */\n            .forEach((positionElement: any) => {\n              positionElements(\n                _getHtmlElement(positionElement.target),\n                _getHtmlElement(positionElement.element),\n                positionElement.attachment,\n                positionElement.appendToBody,\n                this.options,\n                rendererFactory.createRenderer(null, null)\n              );\n            });\n        });\n      });\n    }\n  }\n\n  position(options: PositioningOptions): void {\n    this.addPositionElement(options);\n  }\n\n  get event$(): Observable<number|Event> {\n    return this.triggerEvent$;\n  }\n\n  disable(): void {\n    this.isDisabled = true;\n  }\n\n  enable(): void {\n    this.isDisabled = false;\n  }\n\n  addPositionElement(options: PositioningOptions): void {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  }\n\n  calcPosition(): void {\n    this.update$$.next();\n  }\n\n  deletePositionElement(elRef: ElementRef): void {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  }\n\n  setOptions(options: Options) {\n    this.options = options;\n  }\n}\n\nfunction _getHtmlElement(element: HTMLElement | ElementRef | string): HTMLElement {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element;\n}\n"]},"metadata":{},"sourceType":"module"}